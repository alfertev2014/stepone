
# Концепции языка StepOne

## Обзор

StepOne - это *исследовательский* язык программирования общего назначения, похожий на LISP, созданный как отправная точка для рассмотрения теоретических идей программирования и методологий разработки. Коротко его можно охарактеризовать как "язык языков" или "конструктор языков".

* Это язык с **минималистичным набором фич** и относительно **простым описанием семантики**
* Это легко **расширяемый** язык для создания **DSL** (domain specific language) - как внутренних (embedded), так и полноценных со своим синтаксисом и правилами интерпретации
* Это **строгий** язык со средствами создания **"сильных" абстракций**, позволяющий запрещать определённые возможности в программе так же легко, как и добавлять путём расширения
* Сочетая два предыдущих пункта, можно использовать язык для **моделирования предметных областей**, отделяя процесс реализации программной системы от работы с требованиями к ней и спецификациями
* Это язык со средствами **рассуждения о программах** для анализа различных свойств и обеспечения соответствия их спецификации
* Это язык, на котором относительно удобно писать программы, анализирующие и преобразующие другие программы, например, **компиляторы**, **оптимизаторы**, IDE

## Примеры кода

Как и у любого диалекта LISP, у StepOne очень простой синтаксис выражений, позволяющий легко и однозначно анализировать их как человеку, так и синтаксическому анализатору. В LISP они называются S-выражения - списки, состоящие из символов (идентификаторов), литералов чисел и строк, а также вложенных списков. Они представляют собой последовательность токенов, разделённых пробелами, а с помощью скобок обозначается вложенность списков:

```lisp
(a b (c d) (foo (bar baz)) 1 2 -42 100500.0 "Hello world!")
```

Исполнение программ, записанных в виде S-выражений, происходит слева-направо. Первый элемент списка рассматривается как функция, которая применяется к аргументам, записанным далее:

```lisp
(func arg1 arg2 arg3 ... argn)
```

Если аргументом функции является вложенный список, то он тоже вызывается как функция, и его результат передаётся как аргумент:

```lisp
(f arg1f (g arg1g arg2g) arg3f)
```

В языке есть числа, строки и логические значения. Операции с ними представлены как обычные функции и должны быть вызваны в такой же префиксной форме:

```lisp
(* (+ 2 2) 2) ;; --> 8
(and true false) ;; --> false
```

Кроме синтаксиса вызова функций существуют особые символы, обозначающие макросы. Макрос меняет интерпретацию переданных ему на вход аргументов. Всё дерево переданных макросу аргументов меняет свой смысл. Макрос может определить произвольную интерпретацию переданного ему фрагмента программы:

```lisp
;; код до вызова макроса

(macro
    ;; С этого момента и до соответствующей закрывающей скобки действует семантика, определённая макросом macro.
    something (that has
        (very special meaning))
    (even if contains
        (literals like 1 2 (-42 100500.0) "Hello world")
    )
) ;; конец действия макроса macro
;; код после вызова макроса выполняется как и раньше
```

Таким образом, макросами можно определять произвольный внутренний DSL. Стоит сказать, что макрос - это просто более хитрая функция со своим соглашением о вызове, а не преобразование над исходным кодом с трансляцией его в базовый язык. Макрос исполняется сразу, как функция. Отдельного этапа раскрытия макросов при выполнении программ нет.

Существует ограниченный набор встроенных макросов, предназначенных для построения потока управления (control flow), а также, для объявления символов, пользовательских функций и даже пользовательских макросов.

Например, объявление константы `a`, имеющей значение 4, как результат вычисления выражения `(+ 2 2)`, выглядит так:

```lisp
(
    >- a (+ 2 2)
    * a 3
)
```

Макрос `>-` (читается как `let`), первым аргументом принимает имя (символ), вторым аргументом выражение, которое сразу вычисляет, создаёт привязку имени к вычисленному значению и выполняет оставшийся список аргументов (в примере выше это `* a 3` - умножить `a` на 3). Такой синтаксис продолжения вычисления "хвоста" позволяет в этом хвосте без лишних объявлять другие константы:

```lisp
(
    >- a (+ 2 2)
    >- b (* a 3)
    / b a
)
```

Для ветвлений используется макрос `?` (читается как `if`). Он ожидает первым аргументом логическое выражение условие, вторым аргументом - выражение, возвращаемое, если условие истинно. Если условие ложно, возвращается оставшийся хвост. Это позволяет без лишних скобок писать последовательности проверок:

```lisp
(
    >- x 100500
    ? (< x 100000) 100000
    ? (> x 200000) (/ x 2)
    x
)
```

Функция представляет собой лямбда-выражение. Именованная функция - это константа, которая имеет значение лямбда-выражения. Вместо символа лямбда используется обратный слэш:

```lisp
(
    >- func (\x + x x)
    func 2 ;; применение (\x (+ x x)) к аргументу 2 --> (+ 2 2) --> 4
)
```

Символ `\` (читается как `lambda`) - это встроенный макрос создания анонимной функции-замыкания. Первым аргументом она ожидает символ для именования аргумента. При вызове функции происходит вычисление её аргумента в контексте вызова, привязывание значения аргумента к имени аргумента и вычисление тела функции в контексте создания функции (в замыкании).

Функции являются объектами первого класса (first-class citizen) в языке. Они могут использоваться так же, как и любые другие значения - передаваться как аргумент и возвращаться как значение функции. Функция с двумя аргументами - это каррированная (carried) функция, то есть, функция, принимающая первый аргумент, и возвращающая функцию, ожидающую второй аргумент:

```lisp
(
    >- add (\x \y
        + x y
    )
    add 2 3 ;; --> + 2 3 --> 5
)
```

Лямбда-выражения и объявления констант не являются рекурсивными. Нельзя использовать в теле функции имя, которой эта функция присваивается. Для создания рекурсивных определений используются другие макросы.

Рекурсивная реализация факториала выглядит следующим образом:

```lisp
(
    >- f (@ \f \n
        ? (< n 0) 1
        * n (f (- n 1))
    )
)
```

Разумеется, базовый язык может быть неудобен как для написания, так и для чтения сложных программ. Но возможность описывать произвольные макросы со своими правилами вычислений должна решить эту проблему. Базовый язык служит лишь как элементарный способ выражать семантику других языков, спецификация которых описывается в определении макросов.

## Идеи

Основная идея языка StepOne состоит в том, чтобы это был легко расширяемый язык для создания как DSL (domain specific language), так и языков общего назначения, следуя идее ***языково-ориентированного программирования*** (Language-Oriented Programming). При этом реализация таких языков должна придерживаться принципа **минимальной цены абстракций** (Zero-cost abstraction).

Выбор фич языка StepOne руководствуется следующими противоречащими друг другу принципами:

* Минимизировать описание семантики языка
* Упростить реализацию фич языка на целевых платформах исполнения
* Упростить построение любых востребованных идей, концепций, стилей и практик прикладного программирования

Все базовые конструкции должны быть подобраны таким образом, чтобы любую идею, концепцию, алгоритм, модель предметной области, да и сами фичи языка StepOne можно было выразить и реализовать сравнительно минимальным, прямым и прозрачным способом.

В языке StepOne должны быть развитые средства для анализа и преобразования фрагментов кода, генерации кода для исполнения на различных целевых платформах, оптимизация программ по различным критериям. **Код** на языке StepOne **рассматривается как данные**. Выполнение программы может состоять из нескольких этапов обработки исходного кода перед непосредственным исполнением на целевой платформе с возможным кешированием промежуточного представления. Такую обработку кода можно выделить в отдельные фазы сборки, препроцессинга, компиляции, и даже линковки (linking) перед непосредственным исполнением. В течение каждой фазы могут применяться свои оптимизации. Это позволит создавать выразительные языки высокого уровня и с трансляцией в исполняемый код без лишней цены производительности и потребления памяти.

Чтобы процесс сборки (компилляции) программы был максимально гибким и настраиваемым, предлагается принцип **"компилятор как библиотека"**. Элементы компилятора - это просто библиотеки по преобразованию кода. Синтаксический анализ, работа с промежуточным представлением, генерация исполняемого кода - всё это может быть более расширяемым и настраиваемым, если будет представлено как множество элементарных подключаемых и компонуемых расширений. Они могут быть подключены в программу в различных комбинациях с различными параметрами. Само ядро среды исполнения языка StepOne должно быть простым и минимальным и расширяться за счёт загрузки и применения библиотек, реализующий компиляцию целевого языка для целевой платформы.

В базовой среде исполнения StepOne не должна запрещаться возможность **динамического исполнения** программы на **интерпретаторе** несмотря на компиляцию в исполняемый код. Отдельные фрагменты программы могут выполняться интерпретатором, генерироваться на лету, компилироваться и загружаться для исполнения без перезапуска всей среды исполнения.

Таким образом, среда исполнения языка StepOne представляет собой такую **"очень умную систему сборки"**, потому что чаще всего сама по себе будет применяться для преобразования исходного кода в исполняемые бинарные файлы (или бандлы) целевой платформы исполнения.

## Характеристики Языка

Далее описаны основные характеристики Языка, которые учитываются при его разработке. Это скорее набор требований к Языку нежели строгое описание.

### Базовый язык

В Языке можно выделить _базовый язык_, минимальный по своим возможностям, но обладающий полнотой, свойственной языкам общего назначения (полнотой по Тьюригну). Набор фич базового языка подбирается таким образом, чтобы оставить возможности для большой выразительности, охватить большое количество концепций, парадигм, идиом, паттернов, не включая их все жёстко Язык. Любые популярные техники высокоуровневого программирования должны выражаться по возможности максимально прямо при помощи средств базового языка. Вместе с тем, возможности базового языка не должны содержать лишнего. Если какую-то концепцию можно легко выразить с использованием других более базовых концепций, то эту фичу не стоит включать в базовый язык.

**Минимальность** базового языка состоит в том, что набор фич базового языка является минимально необходимым. Синтаксис состоит из простейших конструкций, из которых можно собирать сложные паттерны, наделённые необходимой семантикой. Грамматика должна быть простой, чтобы допускать простую реализацию парсера. Фичи имеют такую семантику, чтобы допускать простую реализацию среды исполнения. Вариантов выбора такого минимального подмножества фич много. Стоит отдавать предпочтение вариантам, более интуитивно понятным для человека.

**Расширяемость** базового языка состоит в том, чтобы дать программисту больше свободы самому выражать нужные ему сложные идеи, а не навязывать набор встроенных мощных выразительных средств, ограниченных в своей применимости. С помощью фич базового языка можно строить новые конструкции, которые будут выглядеть как полноценные фичи языка, не отличимые от базовых.

**Полнота** базового языка означает, что с использованием одних лишь возможностей базового языка можно выразить всё, что потребуется на практике, даже без применения специальных средств расширения для добавления новых фич. Сам базовый язык является полным по Тьюрингу языком высокого уровня, способный использовать все возможности среды исполнения.

**Простота** базового языка состоит в том, что каждая его фича проста сама по себе с точки зрения понимания и реализации её в среде исполнения. Иными словами, это минимальность реализации всех его фич.

**Независимость** фич базового языка состоит в том, что одну фичу нельзя (трудно) реализовать, используя другие. Две фичи являются _независимыми_, если обе имеют свои уникальные возможности, каждая может присутствовать в языке отдельно от другой, и нельзя (трудно) выразить одну фичу через другую. Набор независимых фич, обладающий полнотой, называется _базисом_. Строго говоря, базис может состоять вообще из одного элемента, через который можно выразить всё (например, однокомбинаторный базис в комбинаторной логике). И такой минимальный базиз может быть не единственный. В языке, ориентированном на практическое применение, не требуется доходить до такой крайности, поэтому требовать строгой независимости фич базового языка не стоит.

Построить такой базис, удовлетворяющий всем требованиям, трудно. Приходится балансировать между теоретическими минимумами из математических абстракций и максимальной адаптированностью к реализации на реальных платформах. Можно придумать много разных базисов, покрывающих одно и то же пространство возможностей. В одних будет много специальных фич, в других будет несколько общих универсальных фич. Нужно определиться, какое пространство возможностей необходимо покрыть в Языке с помощью фич базового языка и средств расширений.  Слишком минималистичные базисы представляют больше интереса в теоретических исследованиях и не применимы напрямую в практических реализациях. Поэтому набор фич базового языка должен быть минимальным и независимым, но оставаться в рамках полноты и простоты базиса.

## Среда исполнения

Для Языка вводится понятие _платформы_, на которой будет происходить исполнение программ. С использованием возможностей платформы строится реализация _среды исполнения_ (runtime environment). В первую очередь, среда исполнения предусматривает реализацию фич базового языка - _базовый рантайм_. Это может быть как самостоятельный интерпретатор, так и библиотека для встраивания в другие скомпилированные программы той же платформы. Или это реализация фич базового языка поверх интерпретатора другого языка - всё зависит от платформы. Фичи базового языка выбираются исходя из простоты реализации базовых рантаймов для широкого множества платформ.

Кроме реализации фич базового языка, некоторые особенные возможности конкретной платформы могут быть включены в среду исполнения как _расширения среды исполнения_, позволяя использовать все возможности целевой платформы. Базовый рантайм содержит лишь реализацию базового языка, но платформа может иметь специальные возможности, которые нельзя или трудно имитировать на базовом рантайме, и легче эти возможности платформы напрямую задействовать в среде исполнения. Таким образом, сам базовый рантайм может быть модульным и позволять подключать дополнительные расширения платформы.

Если программист захочет разрабатывать для конкретной платформы, затачивая программу под все её особенности, у него должна быть такая возможность. Он просто может задействовать платформозависимые расширения. При переходе на другую платформу ему будет доступен другой набор расширений среды исполнения. Эта добровольная **платформозависимость** даёт больше свободы и возможностей, но требует от программиста или от программы больше знаний о конкретной платформе, для которой она написана. Если же программисту потребуется абстрагироваться от платформы и сделать код переносимым между несколькими платформами, то средства Языка всегда позволят ему создавать слои абстракции для выделения общих возможностей из нескольких целевых платформ и написания платформонезависимого кода. Абстрагирование от платформ будет обязанностью программиста или специальных библиотек, а не среды исполнения. Конечно, сама реализация среды исполнения уже может обладать абстрактным интерфейсом, удовлетворяющим платформонезависимому подмножеству, но это ограничивает гибкость среды исполнения при подключении расширений.

### Средства расширения и гибкость

В Языке должны быть развитые средства _расширения синтаксиса и семантики_ для покрытия любых стилей программирования и форм синтаксического сахара. Любой наперёд заданный _DSL_ (Domain Specific Language) должен иметь относительно лёгкую реализацию с помощью фич базового языка, отвечающих за расширяемость (не путать с расширениями рантайма) и абстрагирование. Сам набор этих фич расширения тоже должен быть минималистичным, но достаточно удобным для наиболее прямой и прозрачной реализации желаемого DSL. Такие _расширения языка_ могут оформляться в повторно используемые компоненты, подключаемые и настраиваемые по необходимости. Само применение расширений должно быть лёгким, как простая однострочная декларация в коде или как простое подключение библиотеки. Расширения могут включаться в различных местах кода в различных комбинациях. Расширения должны предусматривать взаимодействия между собой, сочетаемость и разрешение конфликтов.

Реализация среды исполнения может быть такой, чтобы расширения применялись без оверхеда во время исполнения, например, введением дополнительного этапа обработки исходного кода (см. Метапрограммирование) и компиляции в промежуточное представление или в машинный код с применением оптимизаций.

На практике часто возникает потребность ограничить уже включенные возможности языка определёнными соглашениями об их использовании (или неиспользовании), чтобы исключить вероятность ошибок и лучше контроллировать применение фич. Подключение расширения может не только добавлять что-то в текущий язык, но и запрещать фичи других расширений, скрывать лишнее, накладывать ограничение, оставлять только то, что непосредственно требуется для желаемого DSL, чтобы как можно точнее следовать его спецификации.

Синтаксис может расширяться двумя способами:
* расширение семантики интерпретатора конструкций самого языка,
* применение парсеров и трансляторов символьных строк в промежуточное представление на базовом языке

В первом случае имеется возможность изменить интерпретацию даже элементарных синтаксических конструкций базового языка, но сам код не подвергая изменениям. Эти конструкции настолько просты и элементарны, что из них можно строить сложные конструкции, представляющие собой синтаксические паттерны. Расширение синтаксиса может позволить заменить часто повторяющиеся сложные синтаксические паттерны конструкциями, такими же простыми, как элементарные. Базовый рантайм при этом останется без изменений. Сложные расширенные конструкции являются осмысленными только для программиста, а для среды исполнения выглядят как обычный код на базовом языке. Однако, возможности базового языка не позволяют изменить саму среду исполнения, выразить любые желаемые синтаксические правила с точностью до символов. Для этого придётся применить второй подход.

Во втором случае Язык используется для написания транслятора текстовых исходников на другом языке. Программист не ограничен, чтобы задать любую сколь угодно сложную грамматику, не привязанную к синтаксису базового языка. Реализация семантики такого языка может развиваться несколькими путями:

* с делегированием исполнения базовому рантайму:
* * непосредственная интерпретация строки исходника программой-интерпретатором, написанном на базовом языке
* * транспиляция строки исходника в промежуточное представление на базовом языке для последующего многократного запуска
* генерация кода напрямую для платформы, исключая использование базового рантайма
* * генерация исходного кода для другого языка, удобного для целевой платформы, с последующим запуском этапа сборки, предусмотренной другим языком
* * прямая компиляция с генерацией исполняемого кода для целевой платформы средствами самого Языка с последующим запуском этого кода
* генерация кода (исходного или исполняемого) для другой платформы, на которой не реализован базовый рантайм (кросскомпиляция)

Программист волен совмещать в одной программе гибкость синтаксиса конструкций базового языка с фрагментами кода в виде строковых литералов на других языках. Также, есть возможность примененять компиляцию/интерпретацию для отдельных фрагментов исходного кода, возможно, обработанного препроцессорами, или промежуточного представления.

### Метапрограммирование

Возможность метапрограммирования есть во многих языках общего назначения. Оно состоит в том, что одна программа генерирует код другой программы, выполняет анализ и преобразование кода. Для осуществления этой возможности код программы на базовом языке должен рассматриваться как данные. Код на базовом языке транслируется из исходника в _промежуточное представление_. Промежуточное представление - это древовидная структура данных, отражающая структуру кода на базовом языке. Эта структура может обрабатываться различными алгоритмами _препроцессинга_ перед своим непосредственным исполнением, может даже генерироваться на лету, а может вообще не предназначаться для исполнения, а лишь для анализа и создания другого кода на её основе или генерации кода для другой целевой платформы.

Адаптированность Языка к метапрограммированию означает возможность для короткого цикла _бутстраппинга_. На самом Языке можно легко написать интепретатор базового языка и расширять текущий интерпретатор различными фичами с помощью средств расширения синтаксиса.

На Языке можно написать другой рантайм, работающий поверх текущего базового рантайма. Можно написать другой рантайм, работающий по соседству с текущим рантаймом непосредственно на платформе. Полученный новый рантайм может быть слегка изменённым и обладать другими характеристиками, например, оптимизацией, устранением оверхеда абстракций и расширений синтаксиса.

Таких циклов бутстраппинга может быть сколько угодно. Целевые платформы и назначение бутстраппинга могут быть самыми разнообразными. Ограничение должно быть лишь одно: семантика получающихся после метапрограммирования программ и рантаймов должна быть ясна и зафиксирована для программиста и других средств анализа кода.

### Рассуждения о коде

Во время написания кода программист вкладывает в него определённый смысл. Другой программист при чтении кода может понять этот смысл. Не все мысли программиста можно выразить в коде так, чтобы они были в точности так же восприняты другим программистом. Для среды исполнения смысл программного кода будет не такой, каким видят его люди. Какая-то часть смысла программы важна только при чтении кода для понимания человеком. Этот смысл может быть не важен во время исполнения на платформе и при преобразованиях кода, оптимизациях и компиляции.

В идеале язык должен быть настолько выразительным, чтобы позволять фиксировать в коде все ньюансы как семантики исполнения, так и иную дополнительную информацию, которую обычно пишут в комментариях. Эта информация может использоваться для иных рассуждений о коде кроме его обычного исполнения. Комментарии в таком идеальном языке будут излишними, потому что их функцию возьмут на себя обычные выражения языка, понимаемые интерпретаторами или специальными инструментами.

К информации, заложенной в коде, можно отнести:
* семантику непосредственного исполнения на платформе
* семантику исполнения иными способами в специальных окружениях, например, при отладке и профилировании
* информация для процесса сборки и линковки модулей, подсказки и настройки для инлайнинга, дедупликации, сжатия, видимости символов (инкапсуляции)
* информация о типах выражений в аннотациях типов, константность и изменяемость значений
* дополнительная информация о типах, выражающая паттерны проектирования и идиомы языка
* утверждения (assertions) для описания контрактов API, проверяемых статически (системой доказательств) или динамически
* спецификация в дополнение к assertions для доказательства сложных утверждений, и unit-тесты для проверки при запуске

Поведение любого кода и даже нативных расширений рантайма может быть выражено и задокументированно кодом на самом Языке для проведения рассуждений и оптимизаций. Код предназначен не только для запуска и исполнения на различных платформах, но и для участия в разработке других модулей на его основе с применением IDE и средств проверки корректности. Смысл кода - это _все_ возможные его испольнования _всеми_ возможными интерпретаторами (не только средой исполнения).

В языке есть возможность параллельно с рабочим кодом иметь код спецификации его поведения. Спецификация может содержать гораздо больше информации для рассуждений и доказательств. Спецификацией можно покрыть встроенные элементы среды исполнения и платформы, которые не выражаются на самом языке. Спецификацией можно покрыть даже те вещи, которые находятся за гранью платформы и среды исполнения, например, состояние файловой системы или состояние удалённой стороны в сетевом взаимодействии.

Спецификация может быть настолько глубокой и подробной, что её можно соотносить с моделированием поведения программы в масштабах информационной вселенной. Модели бывают разной степени точности в зависимости от задачи. Суть моделирования заключается в опускании неважных деталей из рассмотрения и выделения только до необходимого множества абстрактных свойств и характетистик предмета моделирования. Язык спецификации должен позволять учитывать все возможные детали и ограничивать рассмотрение путём абстрагирования. Складывая простые модели отдельных модулей можно получить модель программной системы.

Любая подобная дополнительная спецификация должна быть опциональной для программы. Программа сама по себе предназначена для выполнения определённых функций, а все дополнительные вещи, которые не относятся к основной функциональности, являются не обязательными, так как реально используются лишь время от времени в других целях.

### Платформы и среда исполнения

Платформой для исполнения программ на Языке может быть любое окружение, в котором возможна реализация базового рантайма. Элементы и фичи базового рантайма должны быть одинаковы на всех платформах. Для отдельных платформ могут существовать свои расширения рантайма с целью задействования оптимизаций или особых возможностей платформы.

От реализации рантайма требуется только представление сущностей базового языка и реализация правил исполнения исходников. При определённых ограничениях на исходники (например, запрет использование зависимых от платформы расширений рантайма), реализацией рантайма должно гарантироваться выполнение следующих требований:

* отсутствие крахов и случаев неконсистентного состояния рантайма
* автоматическое управление памятью, используемой самим рантаймом для выполнения программы (но сама программа может использовать и другую память с другим управлением)
* требования к времени исполнения и потреблению памяти (например, сложность некоторых алгоритмов реализации внутренностей рантайма)

Однако, некоторые расширения рантайма, привязанные к платформе, могут позволять обходить любые ограничения самого рантайма при необходимости. Программист должен получать такую свободу, если он того желает, но тогда контроль и ответственность за поведение он берёт на себя.

Требование к отсутствию крахов и неконсистентного состояния вытекает из того, что в рамках возможностей платформы реализация рантайма накладывает на себя ограничения по использованию возможностей платформы. Во время работы программы для рантайма должны выполняться некоторые инварианты. Если они нарушены, то это считается неконсистентным состоянием рантайма, даже если это допустимо в рамках платформы.

Автоматическое управление памятью при работе рантайма осуществляется для того, чтобы программист не занимался сам выделением и распределением памяти, используя напрямую средства платформы. Рантайм должен сам осуществлять выделение и освобождение памяти для сущностей базового языка и не давать программисту возможности прямой работы с адресами памяти и аллокацией. Однако, это не обязательно должна быть полноценная сборка мусора. Освобождение памяти может осуществляться с использованием метода подсчёта ссылок, или это может быть buddy allocator, или рантайм никогда не будет освобождать память, считая, что она "бесконечна", и её хватит на короткое время работы программы. Программа об этом ничего не знает, её логика на это не полагается. Семантика самого Языка создаёт иллюзию, что память для объектов базового языка как бы бесконечна. Платформа сама может предоставлять автоматическое управление памятью. В этом случае реализация рантайма может использовать средства платформы.

В семантике Языка на его фичи накладывается ограничение, при котором реализация автоматического управления памятью может использовать простой метод подсчёта ссылок. Все фичи Языка должны быть подобраны так, чтобы реализация управления памятью будет простой, и лишь в исключительных случаях (циклы в графе ссылок) ответственность за освобождение памяти перекладывалась бы на программиста или специальные библиотеки. При таких ограничениях возможно применение многих важных оптимизаций, которые было бы сложно задействовать, если дать чуть большую свободу по работе с памятью. Например, в Языке приветствуются неизменяемые значения и программы с однократным присваиванием.

Остальные требования к производительности и потреблению памяти не влияют на семантику языка. Но их тоже стоит придерживаться, чтобы программист на их основе мог хоть немного оценивать производительность своих программ.

Когда в программе используются возможности платформы, которые могут нарушить нормальное поведение рантайма, такой код следует считать небезопасным. Базовый рантайм лишь даёт программисту стартовую точку для использования платформы, но при подключении специальных расширений платформы в ходе работы программы могут быть задействованы такие возможности платформы, что программа выйдет за ограничения базового рантайма вплоть до полного его рассыпания. В этом случае программист должен пользоваться абстракциями платформы и полностью знать реализацию рантайма, ограничения которого он хочет нарушить. Абстракции языка, реализованного базовым рантаймом для него больше не будут действовать.

Наиболее вероятное причины выйти за ограничения рантайма и использовать сырые возможности платформы:

* ручное управление памятью средствами платформы
* взаимодействие с другими возможностями платформы, не предоставленными в реализации базового рантайма
* интеграция с другим кодом, написанными под данную платформу (FFI)
* замена отдельных частей программы эквивалентными интринсиками, реализованными максимально эффективно на платформе

Программист волен обернуть небезопасные вызовы возможностей платформы в высокоуровневый код, абстрагированный от платформы и заставляющий выполнять некоторые ограничения, и продолжать использовать его как "безопасный". Однако, он сам должен проверить, нарушатся ли при этом инварианты рантайма. Сам рантайм не имеет никаких средств защиты от использования небезопасного кода.

# Цели языка и назначение

## Мотивация

Существующие языки созданы для определённых задач, и большинство из них предназначены для написания кода вручную или с применением IDE для облегчения редактирования. Если в дизайне языка встречается какое-то неудобство, то его пытаются решить средствами IDE, или оно просто игнорируется и смиренно принимается программистами. Большинство неудобств языков связаны с

* синтаксисом, с его негибкостью и нерасширяемостью,
* слабой системой типов и плохой выразительностью,
* слабым контролем за компилятором или интерпретатором,
* негибкостью и плохой расширяемостью создаваемых API, в том числе стандартной библиотеки.

Эти недостатки влекут обычно к костылям и велосипедам. Языки могут вынуждать программиста писать много рутинного кода, дублировать логику, писать свои реализации.

Многие языки предоставляют мало информации времени компиляции или средств управления интерпретатором. Компилятор и интерпретатор обычно сложные "комбайны" и воспринимаются программистами как чёрные ящики, семантика языков описывается сложными правилами. Из этого следует, что сделать расширяемые и настраиваемые компилятор, интерпретатор или IDE с удобными визуальными тулзами потребует долгого изучнения их внутренностей.

Хочется иметь язык, в котором расширяется и переиспользуется всё: синтаксис, стандартная библиотека, компилятор, - а не только код, отвечающий за логику приложения. Язык должен подстраиваться под любые желания программиста, чтобы не возникало причин для костылей и велосипедов.

Хочется иметь язык с большей выразительностью, чтобы любые мысли программиста о программе могли быть записаны в коде. Для более точных рассуждений о программах программный код может документироваться большим количеством информации, которая может обрабатываться средствами проверки (верификации). Эта же информация может использоваться для оптимизации при компиляции, эквивалентных преобразованиях (рефакторингах).

Хочется иметь такой язык, в котором прозрачно понятно, как ведёт себя код на всех этапах, предшествующих непоследственному исполнению, а также, как проходит выполнение тех же стадий при линковке модулей между собой, при применении различных расширений, при включении режимов и опций:

* парсинг и валидация исходников,
* препроцессинг макроподстановками,
* преобразования с целью оптимизации,
* генерация промежуточного представления,
* интерпретация или JIT-компиляция для целевой платформы, или генерация кода на другом языке, или генерация машинного кода для нативных исполняемых бинарников.

При всём том, что результирующий язык будет очень сложный, ничто не должно мешать выразить и задокументировать на нём более простые ограниченные языки, легче понимаемые программистами. К сложным языкам можно отнести языки с гибкой и богатой системой типов, статической компиляцией, большим количеством синтаксических конструкций (в том числе сахара). Многие сложные языки не предоставляют возможности включения и отключения отдельных фич. Хочется возможности определить кастомный простой язык, зафиксировать его спецификацию на метаязыке так, чтобы сразу по спецификации из коробки были бы готовы парсер, интерпретатор, оптимизатор, компилятор, интеграция с множеством платформ, сдерства для IDE.

Другими словами, хочется иметь в языке такие средства, чтобы можно было конструировать транслятор из библиотечных блоков и экспериментировать с фичами результирующего языка, пытаясь достичь состояния "языка мечты", а потом зафиксировать его спецификацию, чтобы заниматься оптимизацией компилятора и других средств. Основная сложность состоит в том, чтобы сделать это максимально прозрачным для человека.

## Назначение языка и сферы применения

### Это язык для автоматизации работы с кодом.

Так как код рассматривается как данные, Язык может применяться для всех задач обработки программного кода: парсинг, трансляция, оптимизация, автоматический рефакторинг, автоматическое доказательство утверждений о программах, проверка корректности, вычисление метрик, сравнение и распознавание паттернов в коде. 

Программы на Языке могут парсить код на других языках, разбирать его на абстракции, перерабатывать и делать с ним что-то ещё. Сами синтаксические деревья могут рассматриваться как промежуточное представление на выходе синтаксического анализатора для другого языка. Имея синтаксическое дерево, можно выполнять дальнейшую его обработку и трансляцию в другое промежуточное представление и даже в нативный машинный код. Язык может служить фреймворком для построения парсеров и компиляторов других языков, синтаксических анализаторов и систем автоматического рефакторинга для IDE.

### Это язык представления знаний для программ искусственного интеллекта

Язык предлагает большую гибкость в структурах данных и способах описания алгоритмов их обработки и описания ограничений. Иными словами, Язык может быть использован для описания моделей для различных областей. Он позволяет создать DSL для описания онтологий предметных областей, реализовать системы рассуждений и решать задачи искусственного интеллекта: поиск, удовлетворение ограничений, составление планов и т. д.

### Это язык для создания удобных для человека DSL

Язык может использоваться для создания DSL для различных нужд почти без оверхеда при выполнении. Для желаемого DSL автоматически могут быть созданы интерпретатор, компилятор, анализатор кода, средства рефакторинга и другие инструменты. Сами средства построения DSL предлагают гибкие возможности описания синтаксиса и семантики для максимального соответствия желаемому языку.

### Это клей между разнородными технологиями

Имея гибкие средства построения синтаксиса, Язык позволит строить различные адаптеры к сторонним библиотекам, чтобы склеить и использовать вместе разнородные технологии. Язык годится для написания скриптов, подключая сторонние библиотеки как расширения. С помощью него можно создавать различные средства автоматизации, например, системы сборки, сценарии тестирования, оболочка командного интерпретатора.

### Это встраиваемый язык в другие языки

Язык может быть встроен везде, где может быть запущен рантайм. В этом случае приложение, написанное на других языках, в которое встраивается рантайм Языка, будет выступать платформой для Языка. При каждом запущенном приложении со встроенным рантайм могут быть свои расширения, зависимые от специфики приложения. Рантайм и его расширения возможно написать, например, на платформах C, Java, Python, PHP, Ruby, Javascript... Рантайм может встраиваться в основное приложение как подключаемая библиотека (как отдельный компонент), так и полностью интегрироваться в приложение на этапе сборки исходников (инлайнинг). Рантайм даже может существовать только в compile time, когда встроенный код на Языке полностью транслируется в язык платформы и бесшовно с ним связывается, избавляя от необходимости включать рантайм как дополнительный компонент в приложение.

### Это язык разметки и файлов конфигурации

Синтаксис языка позволяет представлять исходники как данные для интерпретации произвольным образом, не только как логику для исполнения. Например, это могут быть различные файлы конфигурации, для которых существует свой DSL. На Языке можно также реализовать парсеры и обработку таких форматов как XML, JSON, YAML, property files.

# Вопросы реализации

Исходя из описания Языка, можно выделить несколько его особенностей.

## Интерпретатор

Базовый язык должен быть интерпретируемым. Интерпретатором является базовый рантайм, который реализует только базовые возможности, встроенные в язык.

## Примитивные типы данных и элементарные конструкции

К возможностям, входящим в базовый язык, относятся
* примитивные типы данных: числа, строки, символы, байтовые массивы и упакованные структуры
* древовидные и списковые структуры для построения AST: узловые объекты (пары) и кортежи (векторы)
* примитивные операторы для интерпретации AST: последовательное выполнение, ветвление, циклы
* локальные переменные и лексическая область видимости
* функции как значения, вызов функций как замыканий

Набор примитивных типов ограничен только самыми необходимыми для работы с AST и задействования расширений платформы.

## Разделение работы с AST и возможностей платформы

Процесс интерпретации AST базовым рантаймом простой и не расширяемый. Расширение платформы подключается в среду исполнения как неделимый непрозрачный для рантайма объект (набор объектов) и используется в ходе интерпретации AST.

## Зависимость от платформы

Реализация базового рантайма тесно привязывается к платформе, включая все примитивы языка и управление памятью. Реализация может быть написана на любых языках: C/C++, Java, C#, JavaScript, Python и т. д. Реализация рантайма может зависеть от операционной системы, оборудования, ядра, libc и другого окружения. Если это встраиваемый рантайм в другое приложение, то его реализация может тесно переплетаться с этим приложением.

Для конкретных платформ возможно использование специфических расширений базового рантайма для бесшовного взаимодействия с платформой.

## Абстрагирование от платформы

Возможны различные реализации базового рантайма для разных платформ в соответствии с одной спецификацией Языка. Можно выделить определённое подмножество требований к Языку и реализации, которые должны выполняться для всех реализаций. Это гарантирует одинаковую семантику программ при запуске на разных платформах, если не используются специфичные для платформы расширения.

## Стандартизация слоёв абстракции

В языке есть простая возможность создания слоёв абстракции, и содержание некоторых слоёв возможно зафиксировать в виде стандарта.

## Безопасность платформы

Несмотря на требования гибкости и расширяемости Языка, остаётся требование соблюдения некоторых важных инвариантов, чтобы сохранить жизнеспособность самого рантайма. При отсутствии расширений платформы должны сохраняться следующие условия:
* Любые вычисления в ходе выполнения программы, не должны приводить к краху рантайма
* Все вычисления должны иметь определённое поведение - либо стандартное, либо определяемое реализацией. Неопределённое поведение должно быть исключено.
* Корректрость работы с памятью требует автоматического управления, чтобы избегать ошибки обращения к памяти и утечки

Требования к безопасности рантайма могут ограничивать как возможности языка, так и способы реализации. Кроме того, расширения платформы тоже должны следовать этим требованиям. Они могут как угодно работать с возможностями платформы, но не должны затрагивать реализацию рантайма. Небезопасные расширения платформы включаются в программу программистом на его страх и риск.

Автоматическое управление памятью должно допускать реализацию счётчиков ссылок и не требовать серьёзной сборки мусора.

## Бутстраппинг

Язык может допускать компиляцию во что угодно. Сам транслятор может быть написан на языке и потом запускаться на скомпилированном рантайме (бутстраппинг).

Через выражения самого языка и с использованием платформозависимых расширений можно писать новые расширения рантайма вплоть до реализации другого рантайма (бутстраппинг).

## Код как данные, компилятор как библиотека

Язык должен иметь встроенные средства на уровне примитивов, позволяющие рассматривать код как данные, перерабатывать код и легко запускать его.

Все тулзы, связанные с Языком: компиляторы, трансляторы, фреймворки тестирования, верификации, дебаггеры, профайлеры, генераторы кода и оптимизаторы - всё это должно иметь возможность реализации просто библиотеками этого Языка и вызываться в программе в нужные моменты, применяться к нужным фрагментам кода.

## Макроподстановки и компиляция

Базовый язык расширяется при помощи макросов. В отличие от остальных языков, макросы не должны быть отличимы от функций. Считать их макросами или функциями - зависит от их использования. Если применяется компиляция компилятором, написанным на языке, то как таковых этапов компиляции нет. Возможно последовательно выполнить несколько проходов с раскрытием различных макросов, а можно всё сделать в один проход. Возможна частичная компиляция в промежуточное представление до определённого момента, причём, только выбранных участков кода. То, что компилятор является библиотекой языка, позволяет его конфигурировать и применять как угодно.

## Динамическая типизация

Так как язык интерпретируемый, и результат исполнения исходника не известен заранее, применяется динамическая типизация.
