
# Концепции языка StepOne

## Идеи

Основная идея языка StepOne состоит в том, чтобы это был легко расширяемый язык для создания как DSL, так и языков общего назначения, следуя концепции языково-ориентированного программирования. Кроме того, реализации этой идеи должны придерживаться принципа минимальной цены абстракций. В языке должны быть развитые средства для обработки и преобразования фрагментов кода, генерация кода, оптимизация по различным критериям. Это позволит создавать выразительный язык высокого уровня с трансляцией в высокоэффективный исполняемый код без лишнего оверхэда. Чтобы процесс сборки (компилляции) программы был максимально гибким и настраиваемым, предлагается принцип "компилятор как библиотека". Элементы компилятора - это просто библиотеки по преобразованию кода. Они могут быть подключены в программу в различных комбинациях с различными параметрами. Само ядро среды исполнения языка StepOne должно быть простым и минимальным, и расширяться за счёт загрузки и применения библиотек.

## Характеристики языка

Далее описаны основные характеристики языка, которые учитываются при его разработке. Это больше набор требований к языку нежели строгое описание характеристик языка.

### Базовый язык и среда исполнения

В языке StepOne можно выделить минималистичный базовый язык, обладающий полнотой, свойственной языкам общего назначения. Набор возможностей базового языка подбирается таким образом, чтобы дать возможность большой выразительности, охватить большое множество концепций, парадигм, идиом, паттернов. При этом большинство популярных техник программирования должно выражаться максимально прямо через возможности базового языка. Вместе с тем возможности базового языка не должны содержать лишнего. Если какую-то концепцию можно легко выразить, используя другие базовые концепции, то эту фичу не стоит включать в базовый язык.

Синтаксис базового языка должен состоять из простейших конструкций, из которых можно собирать сложные паттерны. Грамматика должна быть простой, чтобы допускать простую реализацию парсера.

**Минимальность** базового языка состоит в том, чтобы дать программисту больше свободы самому выражать нужные ему идеи, а не навязывать ему набор пусть и очень мощных и выразительных средств, но ограниченных в своём применении.

**Полнота** базового языка означает, что с использованием одних лишь возможностей базового языка можно выразить всё, что угодно, что и в более высокоуровневых языках, даже без применения средств расширения.

**Независимость** фич базового языка состоит в том, что одну фичу нельзя (трудно) реализовать, используя другие.

Набор независимых фич, обладающий полнотой, можно называть _базисом_. В идеале построить такой базис для языка программирования трудно. Приходится балансировать между теоретическими минимумами и максимально адаптированными к реализации на реальных платформах. Можно придумать несколько разных базисов, покрывающих одно и то же пространство возможностей. В одних будет много специальных фич, в других будет немного общих универсальных фич. В математике есть формальные системы, показывающие теоретические минимумы базисов. Слишком минималистичные базисы представляют больше интереса в теоретических исследованиях и не применимы прямо в практических реализациях.

Для базового языка, обладающего свойствами минимальности, независимости и полноты, относительно легко построить среду исполнения (runtime environment, или просто рантайм). Собственно, набор фич базового языка выбирается, исходя из простоты реализации базового рантайма на широком множестве платформ.

### Расширяемость и гибкость

В языке должны быть развитые средства расширения синтаксиса и семантики для покрытия любых стилей программирования и форм синтаксического сахара. Любой наперёд заданный DSL должен быть относительно легко реализуем с помощью фич базового языка, отвечающих за расширение. Сам набор этих фич тоже должен быть минималистичным, но достаточно удобным для прямой реализации жлаемого DSL. Расширения языка могут оформляться в повторно используемые компоненты, подключаемые и настраиваемые по необходимости. Само применение расширений должно быть лёгким, как объявление, что с этого момента код начинается на другом расширенном языке. Расширения могут включаться в различных местах кода в различных комбинациях.

Набор средств для расширения языка должен позволять достигать желаемого DSL максимально простым и прямым путём. Реализация рантайма должна быть такой, чтобы расширения применялись без оверхеда во время исполнения. Любой оверхед от абстракций может устраняться дополнительным этапом обработки исходного кода (см. Метапрограммирование) и компиляцией.

Вместе с тем, часто возникает потребность ограничить возможности языка, чтобы исключить вероятность ошибок и лучше контроллировать применение фич. Включение расширения может не только добавлять что-то в текущий контекст, то и запрещать, скрывать, оставлять только то, что непосредственно включено в описание DSL.

Синтаксис может расширяться двумя способами:
* расширение семантики интерпретации конструкций самого языка,
* изменение конкретного синтаксиса с применением парсеров и трансляторов символьных строк.

В первом случае изменяется интерпретация элементарных синтаксических конструкций базового языка, но сами эти конструкции не подвергаются изменениям. Они настолько элементарны, что из них можно сложить широкое множество синтаксических паттернов. Однако, они не позволяют выразить любые желаемые синтаксические правила с точностью до символов.

Во втором случае язык StepOne используется для написания транслятора исходников на другом языке. В этом случае можно задать любую сколь угодно сложную грамматику, не привязанную к синтаксису базового языка.

### Метапрограммирование

* Код может легко рассматриваться как данные, к которым могут быть легко применимы любые алгоритмы преобразования.
* * Ввозможен бутстраппинг, процесс компиляции и сборки программ может быть выражен на этом же языке.

### Платформы и среда исполнения

* Расширения языка, привязанные к платформе, могут позволять обходить любые ограничения самого рантайма при необходимости.
* Возможность реализации на любой платформе с возможностью использования всех средств этой платформы при необходимости.
* Рантайм базового языка должен быть безопасным от крахов и иметь автоматическое управление памятью.

### Рассуждения о коде

* Поведение любого кода, даже нативных расширений, может быть выражено и задокументированно кодом на самом языке для проведения рассуждений и оптимизаций.

# Цели языка и назначение

## Мотивация

Существующие языки созданы для определённых задач и большинство из них предназначены для написания кода вручную с применением IDE для облегчения редактирования. Если в дизайне языка встречается какое-то неудобство, то оно пытается решиться средствами IDE или просто игнорируется и смиренно принимается. Большинство неудобств языков связаны с

* синтаксисом, с его негибкостью и нерасширяемостью,
* слабой системой типов и плохой выразительностью,
* слабым контролем за компилятором или интерпретатором,
* негибкостью и плохой расширяемостью создаваемых API, в том числе стандартной библиотеки.

Эти недостатки влекут обычно к костылям и велосипедам.

Многие языки предоставляют мало информации времени компиляции. Компилятор или интерпретатор обычно сложные и воспринимаются как чёрные ящики, семантика языков описывается сложными правилами. Из этого следует, что сделать расширяемые и настраиваемые компилятор, интерпретатор или IDE с удобными визуальными тулзами - это целое таинство.

Хочется иметь язык, в котором расширяется и переиспользуется всё: синтаксис, стандартная библиотека, компилятор, - а не только код, отвечающий за логику приложения. Язык должен подстраиваться под любые желания программиста, чтобы не возникало причин для костылей и велосипедов.

Хочется иметь язык с большей выразительностью, чтобы любые мысли программиста о программе могли быть записаны в коде. Для более точных рассуждений о программах программный код может документироваться большим количеством информации, которая может обрабатываться средствами проверки (верификации). Эта же информация может использоваться для оптимизации при компиляции, эквивалентных преобразованиях (рефакторингах).

Хочется иметь такой язык, в котором прозрачно понятно, как ведёт себя код на всех этапах, предшествующих непоследственному исполнению, а также, как проходит выполнение тех же стадий при линковке модулей между собой, при применении различных расширений, при включении режимов и опций:

* парсинг и валидация исходников,
* препроцессинг макроподстановками,
* преобразования с целью оптимизации,
* генерация промежуточного представления,
* интерпретация или JIT-компиляция для целевой платформы, или генерация кода на другом языке, или генерация машинного кода для нативных исполняемых бинарников.

При всём том, что результирующий язык будет очень сложный, ничто не должно мешать выразить и задокументировать на нём более простые ограниченные языки, легче понимаемые программистами. К сложным языкам можно отнести языки с гибкой и богатой системой типов, статической компиляцией, большим количеством синтаксических конструкций (в том числе сахара). Многие сложные языки не предоставляют возможности включения и отключения отдельных фич. Хочется возможности определить кастомный простой язык, зафиксировать его спецификацию на метаязыке так, чтобы сразу по спецификации из коробки были бы готовы парсер, интерпретатор, оптимизатор, компилятор, интеграция с множеством платформ, сдерства для IDE.

## Назначение языка и сферы применения

Это язык для автоматизации работы с кодом. Это парсинг, трансляция, оптимизация, автоматический рефакторинг, автоматическое доказательство утверждений о программах, проверка корректности, вычисление метрик, сравнение и распознавание паттернов. Программы на языке могут парсить код на других языках, разбирать его на абстракции, перерабатывать и делать с ним что-то ещё. Некоторые задачи будут труднорешаемые или алгоритмочески неразрешимы. Для их приближённого решения возможно применение алгоритмов искусственного интеллекта. Моя мечта - мержить велосипеды :-)

Это язык представления знаний для программ искусственного интеллекта. Он предлагает большую гибкость в структурах данных и способах описания алгоритмов их обработки и других ограничений. Иными словами, это язык описания моделей и собственно моделирования. Он позволяет создать DSL для описания онтологий предметных областей.

Это язык для создания удобных для человека DSL почти без оверхеда. Язык позволит склеить и использовать вместе разнородные технологии, предоставляя различные средства автоматизации. Короче, это скриптовый язык для создания велосипедов и костылей :-)

Это встраиваемый язык в другие языки. Язык может быть встроен везде, где может быть запущен рантайм. Однако, требование переносимости не стоит, его стоит предявлять к программам на языке, а не к языку. При каждом запущенном рантайме могут быть свои расширения, зависимые от среды исполнения. Рантайм и его расширения возможно написать, например, на C, Java, Python, PHP, Ruby, Javascript...

Этот язык претендует, чтобы убить XML, HTML, CSS и Javascript в мире Web. Претендует, но не будет этим заниматься :-)


# Вопросы реализации

Из этих характеристик сразу следует подход к реализации, включающий несколько особенностей:

* Базовый язык должен быть интерпретируемым. Интерпретатором является базовый рантайм, который реализует только базовые возможности, встроенные в язык.
* К возможностям, входящим в базовый язык, относятся примитивные типы данных, древовидные и списковые структуры для построения AST, примитивные операторы для интерпретации AST, включая последовательное выполнение, ветвление, циклы, вызов функций, лексическую область видимости и другие.
* Набор примитивных типов ограничен только самыми необходимыми для работы с AST и использования возможностей платформы.
* Требования к безопасности рантайма могут ограничивать как возможности языка, так и способы реализации.
* Реализация базового рантайма привязывается к платформе, включая все примитивы языка и управление памятью.
* Возможны различные реализации базового рантайма для разных платформ в соответствии с одной спецификацией.
* В языке есть простая возможность создания слоёв абстракции, и содержание некоторых слоёв возможно зафиксировать в виде стандарта.
* Для конкретных платформ возможно использование специфических расширений базового рантайма для бесшовного взаимодействия с платформой.
* Через выражения самого языка и с использованием платформозависимых расширений можно писать новые расширения рантайма вплоть до реализации другого рантайма (бутстраппинг).

Сам язык имеет свой рантайм и является интерпретируемым. По сути, это интерпретатор бинарных деревьев в памяти, листьями которых могут быть атомы разных полезных примитивных типов данных: числа, байтовые массивы, вектора.

Язык может допускать компиляцию во что угодно. Сам транслятор может быть написан на языке и потом запускаться на скомпилированном рантайме (бутстраппинг).

Язык должен иметь встроенные средства на уровне примитивов, позволяющие рассматривать код как данные, перерабатывать код и легко запускать его.

В языке выделяется базовый язык, имеющий средства для своего расширения. Не стоит слишком увлекаться в минимизации базиса, иначе можно придти к бесполезной математической абстракции. Базовый язык должен допускать просто реализуемый начальный рантайм, позволяющий подключать расширения для связи с системой (ввод-вывод, сеть и т. д.). Базовый язык не должен быть перегружен как Common Lisp большим количеством правил вычисления (особенно при передаче аргументов в функцию).

Начальный рантайм с расширениями должен быть реализован для различных платформ. Сам код на языке может быть кроссплатформенным. Но ничего плохого в том нет, если программа будет знать, где выполняется. Задача кроссплатформенности языка как таковая не стоит. На основе базового языка можно сделать слой абстракции для кроссплатформенного выполнения.

Все тулзы, связанные с языком: компиляторы, трансляторы, фреймворки тестирования, верификации, дебаггеры, профайлеры, генераторы кода и оптимизаторы - всё это должно иметь возможность реализации просто библиотеками этого языка и вызываться в рантайме в нужные моменты, применяться к нужным фрагментам кода.

Базовый язык расширяется при помощи макросов. В отличие от остальных языков, макросы не должны быть отличимы от функций. Считать их макросами или функциями - зависит от их использования. Если применяется компиляция компилятором, написанным на языке, то как таковых этапов компиляции нет. Возможно последовательно выполнить несколько проходов с раскрытием различных макросов, а можно всё сделать в один проход. Возможна частичная компиляция в промежуточное представление до определённого момента, причём, только выбранных участков кода. То, что компилятор является библиотекой языка, позволяет его конфигурировать и применять как угодно.

Этот язык позволяет писать как декларативно, так и процедурно, в зависимости от DSL, который получается при расширении макросами и функциями.


## Требования к языку и реализации

Любые вычисления, выполненные в рамках языка, не должны приводить к краху рантайма
Автоматическое управление памятью должно допускать реализацию счётчиков ссылок и не требовать серьёзной сборки мусора
Любой объект может быть применён как макрос и передан как аргумент другого макроса
Любой макрос при применении должен либо возвращать значение, либо кидать исключение. Тип исключения один - ошибочное выражение.
Существует макрос сравнения символов eq. Отношение равенства символов неизменно на протяжении работы программы.
Функции (макросы) являются чистыми. Значение функции (макроса) зависит только от переданного аргумента и от контекста. В одном и том же контексте при одинаковых (синтаксически) аргументах должны получаться одинаковые (без учёта расположения в памяти) значения.
Каждый объект имеет тип, который можно проверить соответствующими предикатными макросами. Существует макрос, позволяющий получать точную метку типа в виде символа.
Макрос ленивости создаёт объект, который ведёт себя так же, как сразу вычисленный (если не учитывать зацикливания при рекурсии). Нет способа отличить, что перед нами ленивый объект.
Макрос создания рекурсивного определения создаёт объект, ведущий себя как само определение


