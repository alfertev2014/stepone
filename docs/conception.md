
# Концепции Языка

## Идеи

Основная идея Языка состоит в том, чтобы это был легко расширяемый язык для создания как DSL (domain specific language), так и языков общего назначения, следуя концепции языково-ориентированного программирования. Реализации этих идей должны придерживаться принципа минимальной цены абстракций. Все базовые конструкции Языка должны быть подобраны таким образом, чтобы любую идею, концепцию, алгоритм, фичу Языка можно было выразить и реализовать прямым и прозрачным способом.

В Языке должны быть развитые средства для обработки и преобразования фрагментов кода, генерация кода для исполнения на целевой платформе, оптимизация программ по различным критериям. Код на Языке рассматривается как данные. Работа программы может состоять из нескольких уровней обработки кода перед непосредственным исполнением с кешированием промежуточного представления. Такую обработку кода можно выделить в отдельные фазы сборки, препроцессинга, компиляции (и даже линковки) перед непосредственным исполнением. На каждой фазе могут применяться свои оптимизации. Это позволит создавать выразительные языки высокого уровня с трансляцией в исполняемый код без лишнего оверхэда.

Чтобы процесс сборки (компилляции) программы был максимально гибким и настраиваемым, предлагается принцип "компилятор как библиотека". Элементы компилятора - это просто библиотеки по преобразованию кода. Они могут быть подключены в программу в различных комбинациях с различными параметрами. Само ядро среды исполнения языка должно быть простым и минимальным, и расширяться за счёт загрузки и применения библиотек.

В Языке ничто не должно запрещать возможность максимально динамического исполнения несмотря на компиляцию в исполняемый код. Отдельные фрагменты программы могут выполняться интерпретатором, генерироваться на лету, компилироваться и загружаться для исполнения без перезапуска всей среды исполнения.

## Характеристики Языка

Далее описаны основные характеристики Языка, которые учитываются при его разработке. Это больше набор требований к Языку нежели строгое описание.

### Базовый язык

В Языке можно выделить _базовый язык_, минимальный по своим возможностям, но обладающий полнотой, свойственной языкам общего назначения. Набор фич базового языка подбирается таким образом, чтобы дать возможности для большой выразительности, охватить большое количество концепций, парадигм, идиом, паттернов, не включая их все жёстко Язык. Большинство популярных техник высокоуровневого программирования должно выражаться по возможности максимально прямо при помощи средств базового языка. Вместе с тем возможности базового языка не должны содержать лишнего. Если какую-то концепцию можно легко выразить с использованием других более базовых концепций, то эту фичу не стоит включать в базовый язык.

**Минимальность** базового языка состоит в том, что набор фич базового языка является минимально необходимым. Синтаксис состоит из простейших конструкций, из которых можно собирать сложные паттерны, наделённые необходимой семантикой. Грамматика должна быть простой, чтобы допускать простую реализацию парсера. Фичи имеют такую семантику, чтобы допускать простую реализацию среды исполнения.

**Расширяемость** базового языка состоит в том, чтобы дать программисту больше свободы самому выражать нужные ему идеи, а не навязывать ему набор встроенных мощных выразительных средств, ограниченных в своём применении. С помощью фич базового языка можно строить новые конструкции, которые выглядят как полноценные фичи языка наравне с базовыми.

**Полнота** базового языка означает, что с использованием одних лишь возможностей базового языка можно выразить всё, что потребуется на практике, даже без применения специальных средств расширения для добавления новых фич. Сам базовый язык является полным по Тьюрингу языком высокого уровня, предлагающий все возможности среды исполнения.

**Простота** базового языка состоит в том, что каждая его фича проста сама по себе с точки зрения понимания и реализации её в среде исполнения.

**Независимость** фич базового языка состоит в том, что одну фичу нельзя (трудно) реализовать, используя другие. Две фичи являются _независимыми_, если обе имеют свои уникальные возможности, каждая может присутствовать в языке отдельно от другой, и нельзя (трудно) выразить одну фичу через другую. Набор независимых фич, обладающий полнотой, называется _базисом_. Строго говоря, базис может состоять вообще из одного элемента, через который можно выразить всё (например, однокомбинаторный базис в комбинаторной логике), и такой минимальный базиз не единственный. В языке, ориентированном на практическое применение, не требуется доходить до такой крайности, поэтому требовать строгой независимости фич базового языка нельзя.

Построить такой базис для Языка трудно. Приходится балансировать между теоретическими минимумами и максимальной адаптированностью к реализации на реальных платформах. Можно придумать много разных базисов, покрывающих одно и то же пространство возможностей. В одних будет много специальных фич, в других будет несколько общих универсальных фич. Нужно определиться, какое пространство возможностей необходимо покрыть в Языке с помощью фич базового языка и средств расширений. В математике есть формальные системы, демонстрирующие теоретические минимумы для языков программирования (машина Тьюринга, лямбда-исчисление, комбинаторная логика), но всё это лишь математические абстракции. Слишком минималистичные базисы представляют больше интереса в теоретических исследованиях и не применимы напрямую в практических реализациях. Поэтому набор фич базового языка должен быть минимальным и независимым, но оставаться в рамках полноты и простоты базиса.

## Среда исполнения

Для Языка вводится понятие _платформы_, на которой будет происходить исполнение программ. С использованием возможностей платформы строится реализация _среды исполнения_ (runtime environment). В первую очередь среда исполнения предусматривает реализацию фич базового языка - _базовый рантайм_. Это может быть как самостоятельный интерпретатор, так и библиотека для встраивания в другие скомпилированные программы той же платформы, или реализация фич языка поверх интерпретатора другого языка - всё зависит от платформы. Фичи базового языка выбраны исходя из простоты реализации базовых рантаймов на широком множестве платформ.

Кроме реализации фич базового языка некоторые особенные возможности каждой конкретной платформы могут быть включены в среду исполнения как _расширения среды исполнения_, позволяя использовать все возможности целевой платформы. Базовый рантайм содержит лишь реализацию базового языка, но платформа может иметь специальные возможности, которые нельзя или трудно имитировать на базовом рантайме, и легче эти возможности платформы напрямую задействовать в среде исполнения. Таким образом, сам базовый рантайм может быть модульным и позволять подключать дополнительные расширения платформы.

Если программист захочет разрабатывать для конкретной платформы, затачивая программу под все её особенности, у него должна быть такая возможность. Он просто может задействовать платформозависимые расширения. При переходе на другую платформу ему будет доступен другой набор расширений среды исполнения. Эта добровольная **платформозависимость** даёт больше свободы и возможностей, но требует от программиста или от программы больше знаний о конкретной платформе, для которой она написана. Если же программисту потребуется абстрагироваться от платформы и сделать код переносимым между несколькими платформами, то средства Языка всегда позволят ему создавать слои абстракции для выделения общих возможностей из нескольких целевых платформ и написания платформонезависимого кода. Абстрагирование от платформ будет обязанностью программиста или специальных библиотек, а не реализации среды исполнения. Конечно, сама реализация среды исполнения уже может обладать абстрактным интерфейсом, удовлетворяющим платформонезависимому подмножеству, но это ограничивает гибкость среды исполнения при подключении расширений.

### Средства расширения и гибкость

В Языке должны быть развитые средства _расширения синтаксиса_ и семантики для покрытия любых стилей программирования и форм синтаксического сахара. Любой наперёд заданный _DSL_ (Domain Specific Language) должен иметь относительно лёгкую реализацию с помощью фич базового языка, отвечающих за расширяемость (не путать с расширениями рантайма) и абстрагирование. Сам набор этих фич расширения тоже должен быть минималистичным, но достаточно удобным для наиболее прямой и прозрачной реализации желаемого DSL. Такие _расширения языка_ могут оформляться в повторно используемые компоненты, подключаемые и настраиваемые по необходимости. Само применение расширений должно быть лёгким, как простая однострочная декларация в коде или подключение библиотеки. Расширения могут включаться в различных местах кода в различных комбинациях. Расширения должны предусматривать взаимодействия между собой, сочетаемость и разрешение конфликтов.

Реализация среды исполнения может быть такой, чтобы расширения применялись без оверхеда во время исполнения, например, введением дополнительного этапа обработки исходного кода (см. Метапрограммирование) и компиляции в промежуточное представление или в машинный код с применением оптимизаций.

На практике часто возникает потребность ограничить уже включенные возможности языка определёнными соглашениями об их использовании (или неиспользовании), чтобы исключить вероятность ошибок и лучше контроллировать применение фич. Подключение расширения может не только добавлять что-то в текущий язык, но и запрещать фичи других расширений, скрывать лишнее, оставлять только то, что непосредственно требуется для желаемого DSL, чтобы как можно точнее следовать его спецификации.

Синтаксис может расширяться двумя способами:
* расширение семантики интерпретатора конструкций самого языка,
* применение парсеров и трансляторов символьных строк в промежуточное представление на базовом языке

В первом случае имеется возможность изменить интерпретацию даже элементарных синтаксических конструкций базового языка, но сам код не подвергая изменениям. Эти конструкции настолько просты и элементарны, что из них можно строить сложные конструкции, представляющие собой синтаксические паттерны. Расширение синтаксиса может позволить заменить часто повторяющиеся сложные синтаксические паттерны конструкциями, такими же простыми, как элементарные. Базовый рантайм при этом останется без изменений и наличия таких расширений различать не будет. Сложные расширенные конструкции являются осмысленными только для программиста, а для среды исполнения выглядят как обычный код на базовом языке. Однако, возможности базового языка не позволяют изменить саму среду исполнения,  выразить любые желаемые синтаксические правила с точностью до символов. Для этого придётся применить второй подход.

Во втором случае Язык используется для написания транслятора исходников на другом языке. Программист не ограничен, чтобы задать любую сколь угодно сложную грамматику, не привязанную к синтаксису базового языка. Реализация семантики такого языка может развиваться несколькими путями:

* с делегированием исполнения базовому рантайму:
* * непосредственная интерпретация строки исходника программой-интерпретатором, написанном на базовом языке
* * транспиляция строки исходника в промежуточное представление на базовом языке для последующего многократного запуска
* генерация кода напрямую для платформы, исключая использование базового рантайма
* * генерация исходного кода для другого языка, удобного для целевой платформы, с последующим запуском этапа сборки
* * прямая компиляция с генерацией исполняемого кода для целевой платформы средствами самого Языка с последующим запуском этого кода
* генерация кода (исходного или исполняемого) для другой платформы, на которой не реализован базовый рантайм (кросскомпиляция)

Программист волен совмещать в одной программе гибкость синтаксиса конструкций базового языка с фрагментами кода в виде строковых литералов на других языках. Также, есть возможность примененять компиляцию/интерпретацию для отдельных фрагментов исходного кода, обработанного пропроцессорами кода или промежуточного представления.

### Метапрограммирование

Возможность метапрограммирования есть во многих языках общего назначения. Оно состоит в том, чтобы одна программа генерировала код другой программы, выполняла анализ и преобразование кода. Для осуществления этой возможности код программы на базовом языке должен рассматриваться как данные. Код на базовом языке из исходника транслируется в _промежуточное представление_. Промежуточное представление - это древовидная структура данных, отражающая структуру кода на базовом языке. Эта структура может обрабатываться различными алгоритмами _препроцессинга_ перед своим непосредственным исполнением, может даже генерироваться на лету, а может вообще не предназначаться для исполнения, а лишь для анализа и создания другого кода на её основе, генерации кода для другой целевой платформы.

Адаптированность Языка к метапрограммированию означает возможность для короткого цикла _бутстраппинга_. На самом Языке можно легко написать интепретатор базового языка, как и расширять текущий интерпретатор различными фичами средствами расширения синтаксиса.

На Языке можно написать другой рантайм, работающий поверх текущего базового рантайма. Можно написать другой рантайм, работающий по соседству с текущим рантаймом бутстраппинга непосредственно на платформе. Полученный новый рантайм может быть слегка изменённым и обладать другими характеристиками, например, оптимизацией, устранением оверхеда для абстракций и расширений синтаксиса.

Циклов бутстраппинга может быть сколько угодно. Целевые платформы и назначение бутстраппинга могут быть самыми разнообразными. Ограничение должно быть лишь одно: семантика получающихся после метапрограммирования программ и рантаймов должна быть ясна и зафиксирована для программиста и других средств анализа кода.

### Рассуждения о коде

Во время написания кода программист вкладывает в него определённый смысл. Другой программист может понять этот смысл при чтении кода. Не все мысли программиста можно выразить в коде так, чтобы они были в точности восприняты другим программистом. Для среды исполнения смысл программного кода будет другой.

Часть смысла программы важна только при чтении кода для понимания человеком. Этот смысл может быть не важен во время исполнения на платформе при преобразованиях кода, оптимизациях, компиляции.

В идеале язык должен быть настолько выразительным, чтобы позволять фиксировать в коде все ньюансы как семантики исполнения, так и иную дополнительную информацию, которую обычно пишут в комментариях. Комментарии в таком идеальном языке будут излишними, потому что их функцию возьмут на себя обычные выражения языка, понимаемые интерпретаторами и специальными инструментами.

К информации, заложенной в коде, можно отнести:
* семантику непосредственного исполнения на платформе
* семантику исполнения иными способами в специальных окружениях, например, в отладке и профилировании
* информация для процесса сборки и линковки модулей, подсказки и настройки для инлайнинга, дедупликации, сжатия, видимости символов
* информация о типах выражений в аннотациях типов, константность и изменяемость значений
* дополнительная информация о типах, выражающая паттерны проектирования и идиомы языка
* утверждения (assertions) для описания контракта API, проверяемые статически (системой доказательств) или динамически
* спецификация в дополнение к assertions для доказательств сложных утверждений, и unit-тесты для проверки при запуске

Поведение любого кода, даже нативных расширений рантайма, может быть выражено и задокументированно кодом на самом языке для проведения рассуждений и оптимизаций. Код предназначен не только для запуска и исполнения на различных платформах, но и для участия в разработке других модулей на его основе с применением IDE и средств проверки корректности. Смысл кода - это все возможные его испольнования всеми возможными интерпретаторами (не только средой исполнения).

В языке есть возможность параллельно с рабочим кодом иметь код спецификации поведения рабочего кода. Спецификация может содержать гораздо больше информации для рассуждений и доказательств. Спецификацией можно покрыть встроенные элементы среды исполнения и платформы, которые не выражаются на самом языке. Спецификацией можно покрыть даже те вещи, которые находятся за гранью платформы и среды исполнения, например, состояние файловой системы или состояние удалённой стороны в сетевом взаимодействии.

Спецификация может быть настолько глубокой и подробной, что её можно соотносить с моделированием поведения программы в масштабах информационной вселенной. Модели бывают разной степени точности в зависимости от задачи. Суть моделирования заключается в опускании из рассмотрения неважных деталей и абстрагирование до только необходимого множества свойств и характетистик. Язык спецификации должен позволять учитывать все возможные детали и ограничивать рассмотрение путём абстрагирования. Складывая простые модели отдельных модулей можно получить модель программной системы.

### Платформы и среда исполнения

Платформой для исполнения программ на языке может быть любое окружение, в котором возможна реализация базового рантайма. Элементы и фичи базового рантайма должны быть одинаковы на всех платформах. Для отдельных платформ могут существовать свои расширения рантайма с целью задействования особых возможностей платформы или оптимизации.

От реализации рантайма требуется представление сущностей базового языка и реализация правил исполнения исходников. При определённых ограничениях на исходники (например, запрет использования расширений рантайма, зависимых от платформы), реализацией рантайма должно гарантироваться выполнение требований:

* отсутствие крахов и неконсистентного состояния рантайма
* автоматическое управление памятью
* требования к времени исполнения и потреблению памяти (например, сложность алгоритмов)

Однако, расширения рантайма, привязанные к платформе, могут позволять обходить любые ограничения самого рантайма при необходимости. Программист должен получать такую свободу, если он того желает, но тогда контроль и ответственность он берёт на себя.

Требование к отсутствию крахов и неконсистентного состояния вытекает из того, что в рамках возможностей платформы реализация рантайма накладывает на себя ограничения по использованию возможностей платформы. Во время работы рантайма должны выполняться некоторые инварианты. Если они нарушены, то это считается неконсистентным состоянием рантайма, даже если это допустимо в рамках платформы.

Автоматическое управление памятью при работе рантайма осуществляется для того, чтобы программист не занимался сам выделением и распределением памяти, используя напрямую средства платформы. Рантайм должен сам осуществлять выделение и освобождение памяти для сущностей базового рантайма и не давать программисту возможности прямой работы с адресами памяти и аллокацией. Однако, это не обязательно должна быть полноценная сборка мусора. Освобождение памяти может осуществляться по подсчёту ссылок, это может быть buddy allocator, или рантайм никогда не будет освобождать память, считая, что она "бесконечна", и её хватит на короткое время работы программы. Семантика самого языка лишь подразумевает, что память для объектов базового языка как бы бесконечна. Платформа может сама предоставлять автоматическое управление памятью. В этом случае реализация рантайма может использовать средства платформы.

Остальные требования к производительности и потреблению памяти не влияют на семантику языка. Но их тоже стоит придерживаться, чтобы программист на основе них мог хоть немного оценивать производительность своих программ.

Когда в программе используются возможности платформы, которые могут нарушить нормальное поведение рантайма, такой код следует считать небезопасным. Базовый рантайм лишь даёт программисту стартовую точку для использования платформы, но в ходе работы программы могут быть задействованы такие возможности платформы, что программа выйдет за ограничения базового рантайма вплоть до полного его рассыпания. В этом случае программист должен пользоваться абстракциями платформы и полностью знать реализацию рантайма, ограничения которого хочет нарушить. Абстракции языка, реализованного базовым рантаймом для него больше не действуют.

Наиболее вероятное причины выйти за ограничения рантайма и использовать сырые возможности платформы:

* ручное управление памятью средствами платформы
* взаимодействие с другими возможностями платформы, не предоставленными в реализации базового рантайма
* интеграция с другим кодом, написанными под данную платформу
* замена отдельных частей программы эквивалентными интринсиками, реализованными максимально эффективно на платформе

Программист волен обернуть небезопасные вызовы возможностей платформы в высокоуровневый код, абстрагированный от платформы, и продолжать использовать его как "безопасный". Однако, он сам должен проверить, нарушатся ли при этом инварианты рантайма. Сам рантайм не имеет никаких средств защиты от использования небезопасного кода. Программист сам должен помечать для себя некоторые участки кода как небезопасные.

# Цели языка и назначение

## Мотивация

Существующие языки созданы для определённых задач, и большинство из них предназначены для написания кода вручную или с применением IDE для облегчения редактирования. Если в дизайне языка встречается какое-то неудобство, то его пытаются решить средствами IDE, или оно просто игнорируется и смиренно принимается программистами. Большинство неудобств языков связаны с

* синтаксисом, с его негибкостью и нерасширяемостью,
* слабой системой типов и плохой выразительностью,
* слабым контролем за компилятором или интерпретатором,
* негибкостью и плохой расширяемостью создаваемых API, в том числе стандартной библиотеки.

Эти недостатки влекут обычно к костылям и велосипедам. Языки могут вынуждать программиста писать много рутинного кода, дублировать логику, писать свои реализации.

Многие языки предоставляют мало информации времени компиляции или средств управления интерпретатором. Компилятор и интерпретатор обычно сложные "комбайны" и воспринимаются программистами как чёрные ящики, семантика языков описывается сложными правилами. Из этого следует, что сделать расширяемые и настраиваемые компилятор, интерпретатор или IDE с удобными визуальными тулзами потребует долгого изучнения их внутренностей.

Хочется иметь язык, в котором расширяется и переиспользуется всё: синтаксис, стандартная библиотека, компилятор, - а не только код, отвечающий за логику приложения. Язык должен подстраиваться под любые желания программиста, чтобы не возникало причин для костылей и велосипедов.

Хочется иметь язык с большей выразительностью, чтобы любые мысли программиста о программе могли быть записаны в коде. Для более точных рассуждений о программах программный код может документироваться большим количеством информации, которая может обрабатываться средствами проверки (верификации). Эта же информация может использоваться для оптимизации при компиляции, эквивалентных преобразованиях (рефакторингах).

Хочется иметь такой язык, в котором прозрачно понятно, как ведёт себя код на всех этапах, предшествующих непоследственному исполнению, а также, как проходит выполнение тех же стадий при линковке модулей между собой, при применении различных расширений, при включении режимов и опций:

* парсинг и валидация исходников,
* препроцессинг макроподстановками,
* преобразования с целью оптимизации,
* генерация промежуточного представления,
* интерпретация или JIT-компиляция для целевой платформы, или генерация кода на другом языке, или генерация машинного кода для нативных исполняемых бинарников.

При всём том, что результирующий язык будет очень сложный, ничто не должно мешать выразить и задокументировать на нём более простые ограниченные языки, легче понимаемые программистами. К сложным языкам можно отнести языки с гибкой и богатой системой типов, статической компиляцией, большим количеством синтаксических конструкций (в том числе сахара). Многие сложные языки не предоставляют возможности включения и отключения отдельных фич. Хочется возможности определить кастомный простой язык, зафиксировать его спецификацию на метаязыке так, чтобы сразу по спецификации из коробки были бы готовы парсер, интерпретатор, оптимизатор, компилятор, интеграция с множеством платформ, сдерства для IDE.

Другими словами, хочется иметь в языке такие средства, чтобы можно было конструировать транслятор из библиотечных блоков и экспериментировать с фичами результирующего языка, пытаясь достичь состояния "языка мечты", а потом зафиксировать его спецификацию, чтобы заниматься оптимизацией компилятора и других средств. Основная сложность состоит в том, чтобы сделать это максимально прозрачным для человека.

## Назначение языка и сферы применения

### Это язык для автоматизации работы с кодом.

Так как код рассматривается как данные, Язык может применяться для всех задач обработки программного кода: парсинг, трансляция, оптимизация, автоматический рефакторинг, автоматическое доказательство утверждений о программах, проверка корректности, вычисление метрик, сравнение и распознавание паттернов в коде. 

Программы на Языке могут парсить код на других языках, разбирать его на абстракции, перерабатывать и делать с ним что-то ещё. Сами синтаксические деревья могут рассматриваться как промежуточное представление на выходе синтаксического анализатора для другого языка. Имея синтаксическое дерево, можно выполнять дальнейшую его обработку и трансляцию в другое промежуточное представление и даже в нативный машинный код. Язык может служить фреймворком для построения парсеров и компиляторов других языков, синтаксических анализаторов и систем автоматического рефакторинга для IDE.

### Это язык представления знаний для программ искусственного интеллекта

Язык предлагает большую гибкость в структурах данных и способах описания алгоритмов их обработки и описания ограничений. Иными словами, Язык может быть использован для описания моделей для различных областей. Он позволяет создать DSL для описания онтологий предметных областей, реализовать системы рассуждений и решать задачи искусственного интеллекта: поиск, удовлетворение ограничений, составление планов и т. д.

### Это язык для создания удобных для человека DSL

Язык может использоваться для создания DSL для различных нужд почти без оверхеда при выполнении. Для желаемого DSL автоматически могут быть созданы интерпретатор, компилятор, анализатор кода, средства рефакторинга и другие инструменты. Сами средства построения DSL предлагают гибкие возможности описания синтаксиса и семантики для максимального соответствия желаемому языку.

### Это клей между разнородными технологиями

Имея гибкие средства построения синтаксиса, Язык позволит строить различные адаптеры к сторонним библиотекам, чтобы склеить и использовать вместе разнородные технологии. Язык годится для написания скриптов, подключая сторонние библиотеки как расширения. С помощью него можно создавать различные средства автоматизации, например, системы сборки, сценарии тестирования, оболочка командного интерпретатора.

### Это встраиваемый язык в другие языки

Язык может быть встроен везде, где может быть запущен рантайм. В этом случае приложение, написанное на других языках, в которое встраивается рантайм Языка, будет выступать платформой для Языка. При каждом запущенном приложении со встроенным рантайм могут быть свои расширения, зависимые от специфики приложения. Рантайм и его расширения возможно написать, например, на платформах C, Java, Python, PHP, Ruby, Javascript... Рантайм может встраиваться в основное приложение как подключаемая библиотека (как отдельный компонент), так и полностью интегрироваться в приложение на этапе сборки исходников (инлайнинг). Рантайм даже может существовать только в compile time, когда встроенный код на Языке полностью транслируется в язык платформы и бесшовно с ним связывается, избавляя от необходимости включать рантайм как дополнительный компонент в приложение.

### Это язык разметки и файлов конфигурации

Синтаксис языка позволяет представлять исходники как данные для интерпретации произвольным образом, не только как логику для исполнения. Например, это могут быть различные файлы конфигурации, для которых существует свой DSL. На Языке можно также реализовать парсеры и обработку таких форматов как XML, JSON, YAML, property files.

# Вопросы реализации

Исходя из описания Языка, можно выделить несколько его особенностей.

## Интерпретатор

Базовый язык должен быть интерпретируемым. Интерпретатором является базовый рантайм, который реализует только базовые возможности, встроенные в язык.

## Примитивные типы данных и элементарные конструкции

К возможностям, входящим в базовый язык, относятся
* примитивные типы данных: числа, строки, символы, байтовые массивы и упакованные структуры
* древовидные и списковые структуры для построения AST: узловые объекты (пары) и кортежи (векторы)
* примитивные операторы для интерпретации AST: последовательное выполнение, ветвление, циклы
* локальные переменные и лексическая область видимости
* функции как значения, вызов функций как замыканий

Набор примитивных типов ограничен только самыми необходимыми для работы с AST и задействования расширений платформы.

## Разделение работы с AST и возможностей платформы

Процесс интерпретации AST базовым рантаймом простой и не расширяемый. Расширение платформы подключается в среду исполнения как неделимый непрозрачный для рантайма объект (набор объектов) и используется в ходе интерпретации AST.

## Зависимость от платформы

Реализация базового рантайма тесно привязывается к платформе, включая все примитивы языка и управление памятью. Реализация может быть написана на любых языках: C/C++, Java, C#, JavaScript, Python и т. д. Реализация рантайма может зависеть от операционной системы, оборудования, ядра, libc и другого окружения. Если это встраиваемый рантайм в другое приложение, то его реализация может тесно переплетаться с этим приложением.

Для конкретных платформ возможно использование специфических расширений базового рантайма для бесшовного взаимодействия с платформой.

## Абстрагирование от платформы

Возможны различные реализации базового рантайма для разных платформ в соответствии с одной спецификацией Языка. Можно выделить определённое подмножество требований к Языку и реализации, которые должны выполняться для всех реализаций. Это гарантирует одинаковую семантику программ при запуске на разных платформах, если не используются специфичные для платформы расширения.

## Стандартизация слоёв абстракции

В языке есть простая возможность создания слоёв абстракции, и содержание некоторых слоёв возможно зафиксировать в виде стандарта.

## Безопасность платформы

Несмотря на требования гибкости и расширяемости Языка, остаётся требование соблюдения некоторых важных инвариантов, чтобы сохранить жизнеспособность самого рантайма. При отсутствии расширений платформы должны сохраняться следующие условия:
* Любые вычисления в ходе выполнения программы, не должны приводить к краху рантайма
* Все вычисления должны иметь определённое поведение - либо стандартное, либо определяемое реализацией. Неопределённое поведение должно быть исключено.
* Корректрость работы с памятью требует автоматического управления, чтобы избегать ошибки обращения к памяти и утечки

Требования к безопасности рантайма могут ограничивать как возможности языка, так и способы реализации. Кроме того, расширения платформы тоже должны следовать этим требованиям. Они могут как угодно работать с возможностями платформы, но не должны затрагивать реализацию рантайма. Небезопасные расширения платформы включаются в программу программистом на его страх и риск.

Автоматическое управление памятью должно допускать реализацию счётчиков ссылок и не требовать серьёзной сборки мусора.

## Бутстраппинг

Язык может допускать компиляцию во что угодно. Сам транслятор может быть написан на языке и потом запускаться на скомпилированном рантайме (бутстраппинг).

Через выражения самого языка и с использованием платформозависимых расширений можно писать новые расширения рантайма вплоть до реализации другого рантайма (бутстраппинг).

## Код как данные, компилятор как библиотека

Язык должен иметь встроенные средства на уровне примитивов, позволяющие рассматривать код как данные, перерабатывать код и легко запускать его.

Все тулзы, связанные с Языком: компиляторы, трансляторы, фреймворки тестирования, верификации, дебаггеры, профайлеры, генераторы кода и оптимизаторы - всё это должно иметь возможность реализации просто библиотеками этого Языка и вызываться в программе в нужные моменты, применяться к нужным фрагментам кода.

## Макроподстановки и компиляция

Базовый язык расширяется при помощи макросов. В отличие от остальных языков, макросы не должны быть отличимы от функций. Считать их макросами или функциями - зависит от их использования. Если применяется компиляция компилятором, написанным на языке, то как таковых этапов компиляции нет. Возможно последовательно выполнить несколько проходов с раскрытием различных макросов, а можно всё сделать в один проход. Возможна частичная компиляция в промежуточное представление до определённого момента, причём, только выбранных участков кода. То, что компилятор является библиотекой языка, позволяет его конфигурировать и применять как угодно.

## Динамическая типизация

Так как язык интерпретируемый, и результат исполнения исходника не известен заранее, применяется динамическая типизация.
