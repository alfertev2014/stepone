Идея языка в том, чтобы создать язык языков - легко расширяемый язык для создания DSL, допускающий реализацию расширений без оверхеда. Кроме расширений языка также должна быть возможность ограничивать язык до произвольного подмножества.

Сам язык имеет свой рантайм и является интерпретируемым. По сути, это интерпретатор бинарных деревьев в памяти, листьями которых могут быть атомы разных полезных примитивных типов данных: числа, байтовые массивы, вектора.

Язык может допускать компиляцию во что угодно. Сам транслятор может быть написан на языке и потом запускаться на скомпилированном рантайме (бутстраппинг).

Язык должен иметь встроенные средства на уровне примитивов, позволяющие рассматривать код как данные, перерабатывать код и легко запускать его.

В языке выделяется базовый язык, имеющий средства для своего расширения. Не стоит слишком увлекаться в минимизации базиса, иначе можно придти к бесполезной математической абстракции. Базовый язык должен допускать просто реализуемый начальный рантайм, позволяющий подключать расширения для связи с системой (ввод-вывод, сеть и т. д.). Базовый язык не должен быть перегружен как Common Lisp большим количеством правил вычисления (особенно при передаче аргументов в функцию).

Начальный рантайм с расширениями должен быть реализован для различных платформ. Сам код на языке может быть кроссплатформенным. Но ничего плохого в том нет, если программа будет знать, где выполняется. Задача кроссплатформенности языка как таковая не стоит. На основе базового языка можно сделать слой абстракции для кроссплатформенного выполнения.

Все тулзы, связанные с языком: компиляторы, трансляторы, фреймворки тестирования, верификации, дебаггеры, профайлеры, генераторы кода и оптимизаторы - всё это должно иметь возможность реализации просто библиотеками этого языка и вызываться в рантайме в нужные моменты, применяться к нужным фрагментам кода.

Базовый язык расширяется при помощи макросов. В отличие от остальных языков, макросы не должны быть отличимы от функций. Считать их макросами или функциями - зависит от их использования. Если применяется компиляция компилятором, написанным на языке, то как таковых этапов компиляции нет. Возможно последовательно выполнить несколько проходов с раскрытием различных макросов, а можно всё сделать в один проход. Возможна частичная компиляция в промежуточное представление до определённого момента, причём, только выбранных участков кода. То, что компилятор является библиотекой языка, позволяет его конфигурировать и применять как угодно.

Этот язык позволяет писать как декларативно, так и процедурно, в зависимости от DSL, который получается при расширении макросами и функциями.



Цели языка:

Это язык для автоматизации работы с кодом. Это парсинг, трансляция, оптимизация, автоматический рефакторинг, автоматическое доказательство утверждений о программах, проверка корректности, вычисление метрик, сравнение и распознавание паттернов. Программы на языке могут парсить код на других языках, разбирать его на абстракции, перерабатывать и делать с ним что-то ещё. Некоторые задачи будут труднорешаемые или алгоритмочески неразрешимы. Для их приближённого решения возможно применение алгоритмов искусственного интеллекта. Моя мечта - мержить велосипеды :-)

Это язык представления знаний для программ искусственного интеллекта. Он предлагает большую гибкость в структурах данных и способах описания алгоритмов их обработки и других ограничений. Иными словами, это язык описания моделей и собственно моделирования. Он позволяет создать DSL для описания онтологий предметных областей.

Это язык для создания удобных для человека DSL почти без оверхеда. Язык позволит склеить и использовать вместе разнородные технологии, предоставляя различные средства автоматизации. Короче, это скриптовый язык для создания велосипедов и костылей :-)

Это встраиваемый язык в другие языки. Язык может быть встроен везде, где может быть запущен рантайм. Однако, требование переносимости не стоит, его стоит предявлять к программам на языке, а не к языку. При каждом запущенном рантайме могут быть свои расширения, зависимые от среды исполнения. Рантайм и его расширения возможно написать, например, на C, Java, Python, PHP, Ruby, Javascript...

Этот язык претендует, чтобы убить XML, HTML, CSS и Javascript в мире Web. Претендует, но не будет этим заниматься :-)


Требования к языку:

Любые вычисления, выполненные в рамках языка, не должны приводить к краху рантайма
Автоматическое управление памятью должно допускать реализацию счётчиков ссылок и не требовать серьёзной сборки мусора
Любой объект может быть применён как макрос и передан как аргумент другого макроса
Любой макрос при применении должен либо возвращать значение, либо кидать исключение. Тип исключения один - ошибочное выражение.
Существует макрос сравнения символов eq. Отношение равенства символов неизменно на протяжении работы программы.
Функции (макросы) являются чистыми. Значение функции (макроса) зависит только от переданного аргумента и от контекста. В одном и том же контексте при одинаковых (синтаксически) аргументах должны получаться одинаковые (без учёта расположения в памяти) значения.
Каждый объект имеет тип, который можно проверить соответствующими предикатными макросами. Существует макрос, позволяющий получать точную метку типа в виде символа.
Макрос ленивости создаёт объект, который ведёт себя так же, как сразу вычисленный (если не учитывать зацикливания при рекурсии). Нет способа отличить, что перед нами ленивый объект.
Макрос создания рекурсивного определения создаёт объект, ведущий себя как само определение


