
# Концепции языка StepOne

## Идеи

Основная идея языка StepOne состоит в том, чтобы это был легко расширяемый язык для создания как DSL, так и языков общего назначения, следуя концепции языково-ориентированного программирования. Кроме того, реализации этой идеи должны придерживаться принципа минимальной цены абстракций. В языке должны быть развитые средства для обработки и преобразования фрагментов кода, генерация кода, оптимизация по различным критериям. Это позволит создавать выразительный язык высокого уровня с трансляцией в высокоэффективный исполняемый код без лишнего оверхэда. Чтобы процесс сборки (компилляции) программы был максимально гибким и настраиваемым, предлагается принцип "компилятор как библиотека". Элементы компилятора - это просто библиотеки по преобразованию кода. Они могут быть подключены в программу в различных комбинациях с различными параметрами. Само ядро среды исполнения языка StepOne должно быть простым и минимальным, и расширяться за счёт загрузки и применения библиотек.

## Характеристики языка

Далее описаны основные характеристики языка, которые учитываются при его разработке. Это больше набор требований к языку нежели строгое описание характеристик языка.

### Базовый язык и среда исполнения

В языке StepOne можно выделить минималистичный базовый язык, обладающий полнотой, свойственной языкам общего назначения. Набор фич базового языка подбирается таким образом, чтобы дать возможность большой выразительности, охватить большое множество концепций, парадигм, идиом, паттернов. При этом большинство популярных техник программирования должно выражаться максимально прямо через возможности базового языка. Вместе с тем возможности базового языка не должны содержать лишнего. Если какую-то концепцию можно легко выразить, используя другие базовые концепции, то эту фичу не стоит включать в базовый язык.

Синтаксис базового языка должен состоять из простейших конструкций, из которых можно собирать сложные паттерны, наделённые необходимой семантикой. Грамматика должна быть простой, чтобы допускать простую реализацию парсера.

**Минимальность** базового языка состоит в том, чтобы дать программисту больше свободы самому выражать нужные ему идеи, а не навязывать ему набор пусть и очень мощных выразительных средств, но ограниченных в своём применении.

**Полнота** базового языка означает, что с использованием одних лишь возможностей базового языка можно выразить всё, что потребуется на практике, как и в более высокоуровневых языках, даже без применения специальных средств расширения.

**Независимость** фич базового языка состоит в том, что одну фичу нельзя (трудно) реализовать, используя другие. Набор независимых фич, обладающий полнотой, можно называть _базисом_. В теории базис может состоять вообще из одного элемента, через который можно выразить всё (например, однокомбинаторный базис в комбинаторной логике), и такой минимальный базиз не единственный. В языке, ориентированном на практическое применение, не требуется доходить до такой крайности, поэтому требовать строгой независимости фич базового языка нельзя. Независимость фич может означать, что их трудно реализовать одну через другую, но обязательно выполняется условие, что каждая фича может существовать отдельно от других фич, не требовать их обязательного присутствия.

В идеале построить такой базис для языка программирования трудно. Приходится балансировать между теоретическими минимумами и максимальной адаптированностью к реализации на реальных платформах. Можно придумать несколько разных базисов, покрывающих одно и то же пространство возможностей. В одних будет много специальных фич, в других будет немного общих универсальных фич. В математике есть формальные системы, показывающие теоретические минимумы базисов (машина Тьюринга, лямбда-исчисление, комбинаторная логика). Слишком минималистичные базисы представляют больше интереса в теоретических исследованиях и не применимы прямо в практических реализациях.

Для языка StepOne вводится понятие _платформы_, на которой будет происходить исполнение программ. С использованием возможностей платформы строится реализация _среды исполнения_ (runtime environment, или просто рантайм). В первую очередь среда исполнения предусматривает реализацию фич базового языка - базовый рантайм. Для базового языка, обладающего свойствами минимальности, независимости и полноты, относительно легко построить такую же простую и минимальную среду исполнения. Собственно, набор фич базового языка выбирается, исходя из простоты реализации базового рантайма на широком множестве платформ.

Кроме реализации базового рантайма возможности каждой конкретной платформы могут быть включены в среду исполнения как _расширения среды исполнения_, позволяя использовать все возможности целевой платформы. Если программист захочет разрабатывать для конкретной платформы, затачивая программу под все её особенности, у него должна быть такая возможность. При переходе на другую платформу будет другой набор расширений среды исполнения. Эта добровольная **платформозависимость** даёт больше свободы и возможностей, но требует от программиста или от программы осведомлённости о платформе, для которой она написана. Если же программисту потребуется абстрагироваться от платформы и сделать код переносимым, то создание слоёв абстракции, общих для нескольких целевых платформ, будет его обязанностью, а не обязанностью среды исполнения. Предполагается, что язык StepOne настолько гибкий и удобный, что создание платформонезависимого слоя не будет представлять трудности.

### Расширяемость и гибкость

В языке должны быть развитые средства расширения синтаксиса и семантики для покрытия любых стилей программирования и форм синтаксического сахара. Любой наперёд заданный _DSL_ (Domain Specific Language) должен быть относительно легко реализуем с помощью фич базового языка, отвечающих за расширяемость (не путать с расширениями рантайма) и абстрагирование. Сам набор этих фич тоже должен быть минималистичным, но достаточно удобным для прямой реализации желаемого DSL. _Расширения языка_ могут оформляться в повторно используемые компоненты, подключаемые и настраиваемые по необходимости. Само применение расширений должно быть лёгким, как декларация или подключение модуля. Расширения могут включаться в различных местах кода в различных комбинациях.

Набор средств для расширения языка должен позволять достигать желаемого DSL максимально простым и прямым путём. Реализация рантайма может быть даже такой, чтобы расширения применялись без оверхеда во время исполнения. Любой оверхед от абстракций может устраняться дополнительным этапом обработки исходного кода (см. Метапрограммирование) и компиляцией.

Вместе с тем, часто возникает потребность ограничить возможности языка, чтобы исключить вероятность ошибок и лучше контроллировать применение фич. Включение расширения может не только добавлять что-то в текущий язык, но и запрещать, скрывать, оставлять только то, что непосредственно требуется по описанию DSL.

Синтаксис может расширяться двумя способами:
* расширение семантики интерпретации конструкций самого языка,
* применение парсеров и трансляторов символьных строк в промежуточное представление базового языка

В первом случае изменяется интерпретация элементарных синтаксических конструкций базового языка, но сами эти конструкции не подвергаются изменениям. Они настолько элементарны, что из них можно сложить широкое множество синтаксических паттернов. Базовый рантайм остаётся без изменений и не различает никаких расширений. Сложные расширенные конструкции являются осмысленными только для программиста, а для среды исполнения выглядят как обычный код на базовом языке. Однако, возможности базового языка не позволяют изменить саму среду исполнения,  выразить любые желаемые синтаксические правила с точностью до символов. Для этого придётся применить второй подход.

Во втором случае язык StepOne используется для написания транслятора исходников на другом языке. Программист не ограничен, чтобы задать любую сколь угодно сложную грамматику, не привязанную к синтаксису базового языка. Реализация транслятора такого языка может развиваться несколькими путями:

* с делегированием исполнения базовому рантайму:
* * непосредственноая интерпретация строки исходника программой на базовом языке
* * трансляция строки исходника с генерацией промежуточного представления кода на базовом языке для могократного запуска
* генерация кода напрямую для платформы, исключая использование базового рантайма
* * генерация исходного кода с последующим запуском этапа сборки на целевой платформе 
* * компиляция с генерацией исполняемого кода для целевой платформы средствами самого языка с последующим запуском этого кода
* генерация кода (исходного или исполняемого) для другой платформы, на которой не реализован базовый рантайм

Программист волен совмещать в одной программе гибкость синтаксиса базового языка со строковыми фрагментами кода на других языках, как и применение компиляции/интерпретации для отдельных фрагментов исходного кода, обработанного кода или промежуточного представления.

### Метапрограммирование

Возможность метапрограммирования есть во многих языках общего назначения. Оно состоит в том, чтобы одна программа генерировала код другой программы, выполняла анализ и преобразование кода. Для осуществления этой возможности код программы на базовом языке должен рассматриваться как данные. Код на базовом языке из исходника транслируется в _промежуточное представление_. Промежуточное представление - это древовидная структура данных, отражающая структуру кода на базовом языке. Эта структура может обрабатываться различными алгоритмами перед своим непосредственным исполнением, может даже генерироваться на лету, а может вообще не предназначаться для исполнения, а лишь для анализа и создания другого кода на её основе, генерации кода для другой целевой платформы.

Метапрограммирование открывает возможность для короткого цикла бутстраппинга. На самом языке можно написать интепретатор базового языка, а можно расширять текущий интерпретатор различными фичами. Можно написать другой рантайм, работающий поверх базового рантайма, а, возможно, и непосредственно на платформе. Изменённый рантайм может обладать другими характеристиками, например, оптимизацией, устранением оверхеда для абстракций и расширений синтаксиса.


### Платформы и среда исполнения

* Расширения языка, привязанные к платформе, могут позволять обходить любые ограничения самого рантайма при необходимости.
* Возможность реализации на любой платформе с возможностью использования всех средств этой платформы при необходимости.
* Рантайм базового языка должен быть безопасным от крахов и иметь автоматическое управление памятью.

### Рассуждения о коде

* Поведение любого кода, даже нативных расширений, может быть выражено и задокументированно кодом на самом языке для проведения рассуждений и оптимизаций.

# Цели языка и назначение

## Мотивация

Существующие языки созданы для определённых задач и большинство из них предназначены для написания кода вручную с применением IDE для облегчения редактирования. Если в дизайне языка встречается какое-то неудобство, то оно пытается решиться средствами IDE или просто игнорируется и смиренно принимается. Большинство неудобств языков связаны с

* синтаксисом, с его негибкостью и нерасширяемостью,
* слабой системой типов и плохой выразительностью,
* слабым контролем за компилятором или интерпретатором,
* негибкостью и плохой расширяемостью создаваемых API, в том числе стандартной библиотеки.

Эти недостатки влекут обычно к костылям и велосипедам.

Многие языки предоставляют мало информации времени компиляции. Компилятор или интерпретатор обычно сложные и воспринимаются как чёрные ящики, семантика языков описывается сложными правилами. Из этого следует, что сделать расширяемые и настраиваемые компилятор, интерпретатор или IDE с удобными визуальными тулзами - это целое таинство.

Хочется иметь язык, в котором расширяется и переиспользуется всё: синтаксис, стандартная библиотека, компилятор, - а не только код, отвечающий за логику приложения. Язык должен подстраиваться под любые желания программиста, чтобы не возникало причин для костылей и велосипедов.

Хочется иметь язык с большей выразительностью, чтобы любые мысли программиста о программе могли быть записаны в коде. Для более точных рассуждений о программах программный код может документироваться большим количеством информации, которая может обрабатываться средствами проверки (верификации). Эта же информация может использоваться для оптимизации при компиляции, эквивалентных преобразованиях (рефакторингах).

Хочется иметь такой язык, в котором прозрачно понятно, как ведёт себя код на всех этапах, предшествующих непоследственному исполнению, а также, как проходит выполнение тех же стадий при линковке модулей между собой, при применении различных расширений, при включении режимов и опций:

* парсинг и валидация исходников,
* препроцессинг макроподстановками,
* преобразования с целью оптимизации,
* генерация промежуточного представления,
* интерпретация или JIT-компиляция для целевой платформы, или генерация кода на другом языке, или генерация машинного кода для нативных исполняемых бинарников.

При всём том, что результирующий язык будет очень сложный, ничто не должно мешать выразить и задокументировать на нём более простые ограниченные языки, легче понимаемые программистами. К сложным языкам можно отнести языки с гибкой и богатой системой типов, статической компиляцией, большим количеством синтаксических конструкций (в том числе сахара). Многие сложные языки не предоставляют возможности включения и отключения отдельных фич. Хочется возможности определить кастомный простой язык, зафиксировать его спецификацию на метаязыке так, чтобы сразу по спецификации из коробки были бы готовы парсер, интерпретатор, оптимизатор, компилятор, интеграция с множеством платформ, сдерства для IDE.

## Назначение языка и сферы применения

Это язык для автоматизации работы с кодом. Это парсинг, трансляция, оптимизация, автоматический рефакторинг, автоматическое доказательство утверждений о программах, проверка корректности, вычисление метрик, сравнение и распознавание паттернов. Программы на языке могут парсить код на других языках, разбирать его на абстракции, перерабатывать и делать с ним что-то ещё. Некоторые задачи будут труднорешаемые или алгоритмочески неразрешимы. Для их приближённого решения возможно применение алгоритмов искусственного интеллекта. Моя мечта - мержить велосипеды :-)

Это язык представления знаний для программ искусственного интеллекта. Он предлагает большую гибкость в структурах данных и способах описания алгоритмов их обработки и других ограничений. Иными словами, это язык описания моделей и собственно моделирования. Он позволяет создать DSL для описания онтологий предметных областей.

Это язык для создания удобных для человека DSL почти без оверхеда. Язык позволит склеить и использовать вместе разнородные технологии, предоставляя различные средства автоматизации. Короче, это скриптовый язык для создания велосипедов и костылей :-)

Это встраиваемый язык в другие языки. Язык может быть встроен везде, где может быть запущен рантайм. Однако, требование переносимости не стоит, его стоит предявлять к программам на языке, а не к языку. При каждом запущенном рантайме могут быть свои расширения, зависимые от среды исполнения. Рантайм и его расширения возможно написать, например, на C, Java, Python, PHP, Ruby, Javascript...

Этот язык претендует, чтобы убить XML, HTML, CSS и Javascript в мире Web. Претендует, но не будет этим заниматься :-)


# Вопросы реализации

Из этих характеристик сразу следует подход к реализации, включающий несколько особенностей:

* Базовый язык должен быть интерпретируемым. Интерпретатором является базовый рантайм, который реализует только базовые возможности, встроенные в язык.
* К возможностям, входящим в базовый язык, относятся примитивные типы данных, древовидные и списковые структуры для построения AST, примитивные операторы для интерпретации AST, включая последовательное выполнение, ветвление, циклы, вызов функций, лексическую область видимости и другие.
* Набор примитивных типов ограничен только самыми необходимыми для работы с AST и использования возможностей платформы.
* Требования к безопасности рантайма могут ограничивать как возможности языка, так и способы реализации.
* Реализация базового рантайма привязывается к платформе, включая все примитивы языка и управление памятью.
* Возможны различные реализации базового рантайма для разных платформ в соответствии с одной спецификацией.
* В языке есть простая возможность создания слоёв абстракции, и содержание некоторых слоёв возможно зафиксировать в виде стандарта.
* Для конкретных платформ возможно использование специфических расширений базового рантайма для бесшовного взаимодействия с платформой.
* Через выражения самого языка и с использованием платформозависимых расширений можно писать новые расширения рантайма вплоть до реализации другого рантайма (бутстраппинг).

Сам язык имеет свой рантайм и является интерпретируемым. По сути, это интерпретатор бинарных деревьев в памяти, листьями которых могут быть атомы разных полезных примитивных типов данных: числа, байтовые массивы, вектора.

Язык может допускать компиляцию во что угодно. Сам транслятор может быть написан на языке и потом запускаться на скомпилированном рантайме (бутстраппинг).

Язык должен иметь встроенные средства на уровне примитивов, позволяющие рассматривать код как данные, перерабатывать код и легко запускать его.

В языке выделяется базовый язык, имеющий средства для своего расширения. Не стоит слишком увлекаться в минимизации базиса, иначе можно придти к бесполезной математической абстракции. Базовый язык должен допускать просто реализуемый начальный рантайм, позволяющий подключать расширения для связи с системой (ввод-вывод, сеть и т. д.). Базовый язык не должен быть перегружен как Common Lisp большим количеством правил вычисления (особенно при передаче аргументов в функцию).

Начальный рантайм с расширениями должен быть реализован для различных платформ. Сам код на языке может быть кроссплатформенным. Но ничего плохого в том нет, если программа будет знать, где выполняется. Задача кроссплатформенности языка как таковая не стоит. На основе базового языка можно сделать слой абстракции для кроссплатформенного выполнения.

Все тулзы, связанные с языком: компиляторы, трансляторы, фреймворки тестирования, верификации, дебаггеры, профайлеры, генераторы кода и оптимизаторы - всё это должно иметь возможность реализации просто библиотеками этого языка и вызываться в рантайме в нужные моменты, применяться к нужным фрагментам кода.

Базовый язык расширяется при помощи макросов. В отличие от остальных языков, макросы не должны быть отличимы от функций. Считать их макросами или функциями - зависит от их использования. Если применяется компиляция компилятором, написанным на языке, то как таковых этапов компиляции нет. Возможно последовательно выполнить несколько проходов с раскрытием различных макросов, а можно всё сделать в один проход. Возможна частичная компиляция в промежуточное представление до определённого момента, причём, только выбранных участков кода. То, что компилятор является библиотекой языка, позволяет его конфигурировать и применять как угодно.

Этот язык позволяет писать как декларативно, так и процедурно, в зависимости от DSL, который получается при расширении макросами и функциями.


## Требования к языку и реализации

Любые вычисления, выполненные в рамках языка, не должны приводить к краху рантайма
Автоматическое управление памятью должно допускать реализацию счётчиков ссылок и не требовать серьёзной сборки мусора
Любой объект может быть применён как макрос и передан как аргумент другого макроса
Любой макрос при применении должен либо возвращать значение, либо кидать исключение. Тип исключения один - ошибочное выражение.
Существует макрос сравнения символов eq. Отношение равенства символов неизменно на протяжении работы программы.
Функции (макросы) являются чистыми. Значение функции (макроса) зависит только от переданного аргумента и от контекста. В одном и том же контексте при одинаковых (синтаксически) аргументах должны получаться одинаковые (без учёта расположения в памяти) значения.
Каждый объект имеет тип, который можно проверить соответствующими предикатными макросами. Существует макрос, позволяющий получать точную метку типа в виде символа.
Макрос ленивости создаёт объект, который ведёт себя так же, как сразу вычисленный (если не учитывать зацикливания при рекурсии). Нет способа отличить, что перед нами ленивый объект.
Макрос создания рекурсивного определения создаёт объект, ведущий себя как само определение


