Язык программирования StepOne

Введение

Эта книга о создании языка программирования StepOne, идеи которого взяты из языков функционального программирования.

Функциональное программирование хорошо сочетается с метапрограммированием и параллельным программированием без блокировок разделяемых данных. Оно является подмножеством декларативного программирования, в котором программы представлены как данные, а их семантика определяется интерпретаторами, на вход которых они подаются.

Идея языка состоит в том, чтобы, начиная с функционального и метапрограммирования, расширить язык другими парадигмами, в том числе наделить его всеми возможностями декларативного программирования. На всё это уже способен любой Lisp, но этот язык встречает немного другие требования, которым популярные стандарты Lisp плохо удовлетворяют.

Не очень давно появилось понятие языково-ориентированного программирования. Его суть состоит в создании множества простых DSL (Domain Specific Lauguage) из каких-то базовых универсальных яыков. Оно рассматривает любую библиотеку, любой фреймворк, любое расширение языка как создание нового языка из того языка, для которого это расширение было написано. Многие языки программирования имеют средства для расширения множества своих абстракций. Некоторые языки имеют средства для расширения синтаксиса.

Целью языка StepOne является создание новых языков-фреймворков, а не универсальное программирование на нём, как на Common Lisp. Из этой цели вытекают требования к гибкости и расширяемости языка. К этим требованиям добавляется удобство написания программ на этом языке и удобство чтения и понимания работы программы. Сам базовый язык должен включать минимальный набор понятий, а наполнять его смысловыми вещами должен программист.

1. Краткое описание языка

Далее приведено краткое описание языка, его абстракций и реализации. Это по возможности минимальное описание, не включающее подробных разъяснений о назначении конструкций и больших примеров.

1.1 Синтаксис

Синтаксис языка почти повторяет синтаксис Lisp. Однако, в него сознательно вводятся отличия, так как требуется больше соответствовать выработанной концепции, а не традиций. Традиции всё-таки максимально соблюдены, чтобы облегчить привыкание программистов, уже знакомых с аналогичными языками.

1.1.1 Абстрактный синтаксис

Программы и данные на StepOne являются S-выражениями (в книги они будут называться так же, как у Маккарти). Программы, которые возможно написать в виде текста, подаваемого на интерпретацию, имеют более ограниченный набор возможных типов объектов, чем данные, получаемые в результате исполнения программ. Поэтому следует уточнить, что далее рассматриваются S-выражения, которые можно без ошибок запустить на исполнение.

S-выражения поверхностно определяются следующим образом:

Атом есть S-выражение.
Точечная пара (далее, просто пара), состоящая из S-выражений, является S-выражением.
Атомами являются символы, числовые литералы и строковые литералы.

Предложения языка не рассматриваются как текстовые. Среда исполнения оперирует деревьями связанных друг с другом объектов различного типа. S-выражения - это просто абстрактные объекты, для которых определяется семантика. Текстовое представление программы является строкой, которую можно получить, применив функцию печати к исходному S-выражению программы. Тем не менее, программы пишутся именно в текстовом виде, а затем преобразуются в S-выражения, пригодные для исполнения.

Правила, определяющие правильные S-выражения, являются абстрактным синтаксисом. Конкретный синтаксис - это правила, определяющие текстовое представление S-выражений. Далее можно увидеть, что конкретный синтаксис задаётся функциями. Вариантов конкретного синтаксиса может быть сколько угодно. Поэтому сейчас пока не вводятся синтаксические обозначения абстрактных объектов.

Абстрактный синтаксис определяется следующим образом. S-выражение представляет собой дерево объектов. Листовые узлы дерева называются атомами. Промежуточными узлами дерева являются упорядоченные пары. У каждой пары есть указатели на левое S-подвыражение и на правое. Таким образом, деревья S-выражений являются бинарными.

Одиночный атом является S-выражением. Если корнем S-выражения является пара, то её левое и правое поддеревья тоже являются S-выражениями.

Атомами могут быть объекты следующих типов: символы, литералы целых чисел, литералы чисел с плавающей точкой, строковые литералы, встроенные макросы и встроенные функции.

Символы - это абстрактные объекты, назначение которых состоит только в идентификации. Это означает, что всё, что с ними можно сделать, это проверять их на равенство или неравенство. В системе исполнения программ не должно быть двух символов, которые рассматриваются как равные.

Литералы являются константными значениями определённого типа. Среди встроенных типов представлены только целые числа, числа с плавающей точкой, строки и байтовые массивы. В вопросах реализации будут рассмотрены возможные варианты этого набора типов.

Базовые макросы - это (почти) минимальный набор макросов, представляющий собой базис. Из них можно определить пользовательские макросы. Смысл этих макросов определяется средой исполнения. Список базовых макросов следующий:

quote - макрос взятия S-выражения в кавычки
if - макрос условных вычислений
lambda - макрос создания замыканий
let - макрос помещения символа в контекст
label - макрос для организации рекурсивных вычислений
lazy - макрос ленивых вычислений
unlazy - макрос принудительного выполнения всех ленивых вычислений
eval - макрос евалуации выражения в текущем контексте стандартным эвалуатором
/// будет меняться

Среди макросов особо выделяются функции. Базовые функции по своей природе ничем не отличаются от базовых макросов. Единственное отличие их в том, что при определении их типа они помечены как функции. Именно базовые функции определяют свойства встроенных типов данных. Для каждого типа данных есть свой набор базовых функций.

Для работы с парами и атомами определяется следующий набор функций:

car
cdr
cons
atom
eq

Для работы с целыми числами определяется следующий набор функций:

i?
i+
i-
i*
i/
i==
i!=
i<
i>
i<=
i>=

Аналогично определяются функции для работы с числами с плавающей точкой:

f?
f+
f-
f*
f/
f==
f!=
f<
f>
f<=
f>=

Отдельно определяются функции для преобразования чисел из одного типа в другой:

i2f
f2i

Все встроенные функции, которые являются бинарными, после применения к первому аргументу возвращают функцию, запоминающую этот аргумент и требующую второй аргумент. То есть, в языке StepOne все функции (даже встроенные) являются каррированными. Подробнее о карринге будет рассказано при описании семантики.

1.1.2 Конкретный синтаксис

Конкретный синтаксис можно задать в нотации Бэкуса-Наура.

<S-выражение> ::= <Атом> | <Список>

<Список> ::= (<Необязательные_пробелы> <S-выражение> <Обязательные_пробелы> <Хвост> <Необязательные_пробелы> )
<Хвост> ::= . <Обязательные_пробелы> <S-выражение> | <S-выражение> <Обязательные_пробелы> <Хвост>

<Атом> ::= <Символ> | <Число> | <Строка>

<Cимвол> ::= <Правильный_идентификатор>

<Число> ::= <Знак> <Последовательность_цифр

<Строка> ::= " <Последовательность_знаков> "

Правильный идентификатор - это последовательность непробельных символов, не принадлежащих следующему множеству: ()[]{}.\".
Числа и строки определяются как в большинстве языков программирования. Строки заключаются именно в двойные кавычки.


1.2 Семантика выражений

Семантика S-выражения - это результат его вычисления. Вычисление определяется для всех объектов, которые могут находиться в памяти при выполнении программы. В вычислении объектов принимает участие контекст. Контекст состоит из объектов, определяющих соответствие символов и значений.

Среди символов особо выделяются nil и t.

Кроме уже перечисленных типов объектов, встречающихся в S-выражениях, в результате вычислений могут появиться объекты следующих типов:

ленивые объекты - хранят снимок контекста и S-выражение, которое требуется вычислить в этом контексте,
рекурсивные метки - хранят символ в качестве метки, снимок контекста и S-выражение для вычисления,
замыкания - хранят символ аргумента, снимок контекста и S-выражение для вычисления.

Для определения семантики S-выражений выбран подход с операционной семантикой. Вводится описание абстрактной машины, которая преобразует исходное S-выражение в результат. В теории языка Lisp существует SECD-машина, определяющая семантику Lisp-программ. Для языка StepOne используется аналогичная похожая машина. Однако, эта машина будет больше напоминать eval-apply-интерпретатор.

Абстрактная машина StepOne работает с абстрактной памятью, состоящей из объектов перечисленных типов и объектов контекста. Предполагается, что для каждого объекта можно получить указатель на него. Пары и другие объекты, которые в себе хранят другие объекты, связаны с ними по указателям. Предполагается, что память бесконечна, сборка мусора не рассматривается, природа памяти и разрядность указателя не имеют значения.

В абстрактной машине определяется три указателя:

указатель на текущий объект S-выражения (исходный код), которое требуется вычислить (С, Code),
указатель на объект-аргумент (P, Parameter),
указатель на текущий контекст (A, Aliases).

Для каждого объекта в системе определяются две операции: eval и apply. Абстрактная машина имеет в себе набор встроенных реализаций этих операций для каждого типа объектов. Выбор той или иной реализации применения операции зависит от типа объекта, на который указывает C.

Предполагается, что машина может использовать множество других указателей, чтобы вычислять встроенные реализации eval и apply.

Работа машины происходит по шагам. Состояние машины после каждого шага называется конфигурацией.

Получение значения S-выражения, или его вычисление, задаётся операцией eval, которая использует указатели C и A. Операция apply использует все три указателя машины. Результатом выполнения операций может быть полученное значение, ошибка вычисления или ошибка, связанная с зацикливанием, когда возврата не происходит вообще.

Для типов объектов существует иерархия наследования. Реализации по-умолчанию для базовых типов могут перекрываться в конкретных типах. Если к требуемой ситуации не подходит ни одна реализация, возвращается ошибка. Все объекты делятся в соответствии со следующим деревом (в скобках описано содержимое объектов):

объекты:
- пары (l - левое поддерево, r - правое поддерево)
- ленивые объекты (c - выражение, a - снимок контекста)
- рекурсивные метки (s - символ-метка, c - выражение, a - снимок контекста)
* атомы:
-- символы
-* константы:
--* специальные типы (v - значение):
---- целые числа
---- числа с плавающей точкой
---- строки
---- байтовые массивы
---- вектора 
---- ... и прочее
--* макросы:
---- пользовательские макросы
---* определённые системой макросы
----- встроенные макросы
----* функции
------ операции
------ замыкания (s - символ, c - выражение, a - снимок контекста)

Кроме операций eval и apply абстрактная машина может создавать свои копии и получать результаты их работы. Это обозначается простым вызовом операции с инициализацией указателей.

Далее приводится только начало таблицы реализаций операций eval и apply. Семантика встроенных функций и макросов будет описана позже более коротко. До знака -> представлено состояние вызова, после знака -> представлено то, что нужно вернуть как результат.

eval(объект, A) -> error
apply(объект, nil, A) -> объект

eval(пара[l:r], A) -> apply(l, r, A)

eval(ленивый[c:a], A) -> eval(пока_не_лень_eval(c, a), A)

eval(C=метка[s:c:a], A) -> eval(eval(c, контекст[s:C:A]), A)

apply(C, nil, A) -> C
apply(C=метка[s:c:a], P, A) -> apply(eval(c, контекст[s:C:A]), P A)

eval(символ, A) -> найти_в_контексте(символ, A)

eval(константа, A) -> константа

apply(функция, nil, A) -> C
apply(функция, пара[l:r], A) -> apply(применить_к_аргументу(функция, eval(l, A)), r, A)

apply(замыкание[s:c:a], пара[l:r], A) -> apply(eval(c, контекст[s:eval(l, A):A]), r, A)

apply(quote, P, A) -> P
apply(if, пара[b:пара[tb:fb]], A) -> если eval(b, A)!=nil - вернуть eval(tb, A), иначе - eval(fb, A)
apply(lambda, пара[s:c], A) -> замыкание[s:c:A]
apply(let, пара[s:пара[v:c]], A) -> eval(c, контекст[s:eval(v, A):A])
apply(label, пара[s:c], A) -> метка[s:c:A]
apply(lazy, C, A) -> ленивый[C:A]
apply(unlazy, C, A) -> пока_не_лень_eval(C, A)
apply(eval, C, A) -> eval(eval(C, A), A)

Унарные базовые функции работают почти как макросы. Отличие функций от макросов в том, что они берут в качестве аргументов элементы списка аргументов, а не весь список. Бинарные функции в результате применения к первому аргументу возвращают свою каррированную версию, которая требует следующий аргумент.

apply(binop, пара[l:r], A) -> apply(binop2[eval(l, A)], r, A)

Здесь binop2 - это унарная функция, в которой хранится первый аргумент.

Теперь следует привести семантику, используя конкретный синтаксис. Предполагается, что определена следующая таблица символов:

' - quote - макрос взятия S-выражения в кавычки
? - if - макрос условных вычислений
\ - lambda - макрос создания замыканий
>- - let - макрос помещения символа в контекст
@ - label - макрос для организации рекурсивных вычислений
# - lazy - макрос ленивых вычислений
$ - unlazy - макрос принудительного выполнения всех ленивых вычислений
~ - eval - макрос евалуации выражения в текущем контексте стандартным эвалуатором



Следующие выражения возвращают символ t для любых x и y. Фигурные скобки означают произвольное выражение, в котором встречаются символы.

(eq (car (cons x y)) x)
(eq (cdr (cons x y)) y)
(eq (atom (' . a)) (' . t))
(eq (atom (' A{})) ())
(eq ((\ x . A{x}) y) A{y})
(eq (>- x y . A{x}) A{y})

1.3 Прагматика

2. Вопросы проектирования языка
2.1 История появления идеи
2.2 Обзор существующих языков
2.3 Цели и требования к языку
2.3.1 Предназначение языка
2.3.2 Требования к синтаксису и абстракциям
2.3.3 Требования к реализации
2.4 Соответствие языка требованиям
2.4.1 Удобство синтаксиса
2.4.2 Возможные пути применения языка
2.4.3 Компромиссы реализации

3. Вопросы реализации среды исполнения
3.1 Фундамент
3.2 Начальный этап
3.3 Бутстраппинг
3.4 Оптимизации

