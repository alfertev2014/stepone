Язык программирования StepOne

Введение

Эта книга о создании языка программирования StepOne, идеи которого взяты из языков функционального программирования.

Функциональное программирование хорошо сочетается с метапрограммированием и параллельным программированием без блокировок разделяемых данных. Оно является подмножеством декларативного программирования, в котором программы представлены как данные, а их семантика определяется интерпретаторами, на вход которых они подаются.

Идея языка состоит в том, чтобы, начиная с функционального и метапрограммирования, расширить язык другими парадигмами, в том числе наделить его всеми возможностями декларативного программирования. На всё это уже способен любой Lisp, но этот язык встречает немного другие требования, которым популярные стандарты Lisp плохо удовлетворяют.

Не очень давно появилось понятие языково-ориентированного программирования. Его суть состоит в создании множества простых DSL (Domain Specific Lauguage) из каких-то базовых универсальных яыков. Оно рассматривает любую библиотеку, любой фреймворк, любое расширение языка как создание нового языка из того языка, для которого это расширение было написано. Многие языки программирования имеют средства для расширения множества своих абстракций. Некоторые языки имеют средства для расширения синтаксиса.

Целью языка StepOne является создание новых языков-фреймворков, а не универсальное программирование на нём, как на Common Lisp. Из этой цели вытекают требования к гибкости и расширяемости языка. К этим требованиям добавляется удобство написания программ на этом языке и удобство чтения и понимания работы программы. Сам базовый язык должен включать минимальный набор понятий, а наполнять его смысловыми вещами должен программист.

1. Краткое описание языка

Далее приведено краткое описание языка, его абстракций и реализации. Это по возможности минимальное описание, не включающее подробных разъяснений о назначении конструкций и больших примеров.

1.1 Синтаксис

Синтаксис языка почти повторяет синтаксис Lisp. Однако, в него сознательно вводятся отличия, так как требуется больше соответствовать выработанной концепции, а не традиций. Традиции всё-таки максимально соблюдены, чтобы облегчить привыкание программистов, уже знакомых с аналогичными языками.

1.1.1 Абстрактный синтаксис

Программы и данные на StepOne являются S-выражениями (в книги они будут называться так же, как у Маккарти). Программы, которые возможно написать в виде текста, подаваемого на интерпретацию, имеют более ограниченный набор возможных типов объектов, чем данные, получаемые в результате исполнения программ. Поэтому следует уточнить, что далее рассматриваются S-выражения, которые можно без ошибок запустить на исполнение.

S-выражения поверхностно определяются следующим образом:

Атом есть S-выражение.
Точечная пара (далее, просто пара), состоящая из S-выражений, является S-выражением.
Атомами являются символы, числовые литералы и строковые литералы.

Предложения языка не рассматриваются как текстовые. Среда исполнения оперирует деревьями связанных друг с другом объектов различного типа. S-выражения - это просто абстрактные объекты, для которых определяется семантика. Текстовое представление программы является строкой, которую можно получить, применив функцию печати к исходному S-выражению программы. Тем не менее, программы пишутся именно в текстовом виде, а затем преобразуются в S-выражения, пригодные для исполнения.

Правила, определяющие правильные S-выражения, являются абстрактным синтаксисом. Конкретный синтаксис - это правила, определяющие текстовое представление S-выражений. Далее можно увидеть, что конкретный синтаксис задаётся функциями. Вариантов конкретного синтаксиса может быть сколько угодно. Поэтому сейчас пока не вводятся синтаксические обозначения абстрактных объектов.

Абстрактный синтаксис определяется следующим образом. S-выражение представляет собой дерево объектов. Листовые узлы дерева называются атомами. Промежуточными узлами дерева являются упорядоченные пары. У каждой пары есть указатели на левое S-подвыражение и на правое. Таким образом, деревья S-выражений являются бинарными.

Одиночный атом является S-выражением. Если корнем S-выражения является пара, то её левое и правое поддеревья тоже являются S-выражениями.

Атомами могут быть объекты следующих типов: символы, литералы целых чисел, литералы чисел с плавающей точкой, строковые литералы, встроенные макросы и встроенные функции.

Символы - это абстрактные объекты, назначение которых состоит только в идентификации. Это означает, что всё, что с ними можно сделать, это проверять их на равенство или неравенство. В системе исполнения программ не должно быть двух символов, которые рассматриваются как равные.

Литералы являются константными значениями определённого типа. Среди встроенных типов представлены только целые числа, числа с плавающей точкой, строки и байтовые массивы. В вопросах реализации будут рассмотрены возможные варианты этого набора типов.

Базовые макросы - это (почти) минимальный набор макросов, представляющий собой базис. Из них можно определить пользовательские макросы. Смысл этих макросов определяется средой исполнения. Список базовых макросов следующий:

quote - макрос взятия S-выражения в кавычки
if - макрос условных вычислений
lambda - макрос создания замыканий
let - макрос помещения символа в контекст
label - макрос для организации рекурсивных вычислений
lazy - макрос ленивых вычислений
unlazy - макрос принудительного выполнения всех ленивых вычислений
eval - макрос евалуации выражения в текущем контексте стандартным эвалуатором
/// будет меняться

Среди макросов особо выделяются функции. Базовые функции по своей природе ничем не отличаются от базовых макросов. Единственное отличие их в том, что при определении их типа они помечены как функции. Именно базовые функции определяют свойства встроенных типов данных. Для каждого типа данных есть свой набор базовых функций.

Для работы с парами и атомами определяется следующий набор функций:

car
cdr
cons
atom
eq

Для работы с целыми числами определяется следующий набор функций:

i?
i+
i-
i*
i/
i==
i!=
i<
i>
i<=
i>=

Аналогично определяются функции для работы с числами с плавающей точкой:

f?
f+
f-
f*
f/
f==
f!=
f<
f>
f<=
f>=

Отдельно определяются функции для преобразования чисел из одного типа в другой:

i2f
f2i


1.1.2 Конкретный синтаксис

Конкретный синтаксис можно задать в нотации Бэкуса-Наура.

<S-выражение> ::= <Атом> | <Список>

<Список> ::= (<Необязательные_пробелы> <S-выражение> <Обязательные_пробелы> <Хвост> <Необязательные_пробелы> )
<Хвост> ::= . <Обязательные_пробелы> <S-выражение> | <S-выражение> <Обязательные_пробелы> <Хвост>

<Атом> ::= <Символ> | <Число> | <Строка>

<Cимвол> ::= <Правильный_идентификатор>

<Число> ::= <Знак> <Последовательность_цифр

<Строка> ::= " <Последовательность_знаков> "

Правильный идентификатор - это последовательность непробельных символов, не принадлежащих следующему множеству: ()[]{}.\".
Числа и строки определяются как в большинстве языков программирования. Строки заключаются именно в двойные кавычки.


1.2 Семантика выражений

Семантика S-выражения - это результат его вычисления. Вычисление определяется для всех объектов, которые могут находиться в памяти при выполнении программы. В вычислении объектов принимает участие контекст - объект, определяющий преобразование символов в значения.


1.3 Прагматика

2. Вопросы проектирования языка
2.1 История появления идеи
2.2 Обзор существующих языков
2.3 Цели и требования к языку
2.3.1 Предназначение языка
2.3.2 Требования к синтаксису и абстракциям
2.3.3 Требования к реализации
2.4 Соответствие языка требованиям
2.4.1 Удобство синтаксиса
2.4.2 Возможные пути применения языка
2.4.3 Компромиссы реализации

3. Вопросы реализации среды исполнения
3.1 Фундамент
3.2 Начальный этап
3.3 Бутстраппинг
3.4 Оптимизации

