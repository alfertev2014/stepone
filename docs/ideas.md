Представление в памяти:
использовать компактные в памяти списки. Сделать прозрачный парсер для работы с такими списками. Возможно, такие списки будут играть роль байткода.

Инлайнер:
можно сделать инлайнер всего и вся, разворачивание всех макросов, не выходя за рамки списков, не компилируя ничего

Компиляция:
Написать генератор кода на C и после компиляции вызывать какой-нибудь gcc.

Взаимодействие с другими языками:
Как препроцессор для C-кода, можно добавить абстракции языка C, инклюдить и пережёвывать ашники, генерировать весь код на C. Можно попробовать импортировать сишные программы через ашники и динамическое связывание. Потребуется специальное расширение для dlopen.


Контексты и пространства имён:

Контексты очень похожи на объекты. Когда контекст помещаешь в переменную и его применяешь к символу (операция get), это напоминает вызов метода. По идее, контекст можно применить только к символу, но можно его рассматривать и как евалуатор, при применении он вызывает у аргумента eval в себе. Получается, контекст - это просто особый макрос.

Как импортировать одно пространство имён в другое? Как наложить один контекст на другой?

Нужна эффективная реализация контекстов, получше, чем линейный поиск.

Некоторые способы работы с контекстами можно сделать с индексами де-Брёйна. Есть два способа: считать их от вершины стека или считать их от некоторого начала стека. Если контексты при этом заменять линейными списками, но по ним достаточно пройтись циклом определённое количество раз до нужного значения. Тогда неизвестные символы обнаружатся на этапе “компиляции” - перевода обычных исходников на индексы де-Брёйна. В некоторых случаях, если не пользоваться жёстко замыканиями, можно организовать контекст как вектор, из которого можно брать значения по индексам напрямую. Можно делать гибрид… Но всё это после “компиляции” - довольно глубокого просмотра исходника.

Стоит ли скрывать реализацию контекстов, или предполагать её каноническую реализацию в виде ассоциативных списков? В таком случае, стоит ли вводить особый тип данных для контекстов?


Процессы и потоки:

TODO: Подумать об абстракции параллельно выполняющихся инстансов (в том числе, на разных машинах).




Сам символ нужен для того, чтобы на него указывали. Внутри него ничего нет. Нужно ли для каждого символа занимать память с одним и тем же указателем на vtable? 

Ссылка - вроде просто указатель. Но нам не больно-то хочется указывать на символы, однако, хочется с ними выполнять правильные действия.

Если ссылки - просто указатели, то они меньше занимают, с ними проще работать, легко сравнивать, легко переходить, меньше лишних ифов. Но при этом затрачивается память на объекты. У символов будет vtable и refcount, а в остальном они бесполезны. А ведь символов будет дохера.

Если сделать два типа ссылок: символы и объекты, то ссылки становятся структурными, у них появляется vtable, по ним даже перейти не так просто, трудно сравнить, придётся проверять типы. Но можно исключить vtable из самих объектов.
