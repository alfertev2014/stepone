
>- ' (% p . p)

>- \ (~ a % lambda
	% p ` ((ctx-push a (mcar . lambda) a mcar . p) mcdr . lambda) mcdr . p)

>- eval (~ a % p a a . p)

>- all-basemacro ('
	(-i . m-i)
	(i+ . mi+)
	(i- . mi-)
	(i* . mi*)
	(i/ . mi/)
	(i% . mi%)
	(i? . mi?)
	(i-not . mi-not)
	(i-and . mi-and)
	(i-or . mi-or)
	(i-xor . mi-xor)
	(i-shl . mi-shl)
	(i-shr . mi-shr)
	(i= . mi=)
	(i!= . mi!=)
	(i< . mi<)
	(i> . mi>)
	(i<= . mi<=)
	(i>= . mi>=)

	(u? . mu?)
	(u-not . mu-not)
	(u-and . mu-and)
	(u-or . mu-or)
	(u-xor . mu-xor)
	(u-shl . mu-shl)
	(u-shr . mu-shr)

	(u= . mu=)
	(u!= . mu!=)
	(u< . mu<)
	(u> . mu>)
	(u<= . mu<=)
	(u>= . mu>=)

	(c? . mc?)
	(c-not . mc-not)
	(c-and . mc-and)
	(c-or . mc-or)
	(c-xor . mc-xor)
	(c-shl . mc-shl)
	(c-shr . mc-shr)
	(c= . mc=)
	(c!= . mc!=)
	(c< . mc<)
	(c> . mc>)
	(c<= . mc<=)
	(c>= . mc>=)

	(-f . m-f)
	(f+ . mf+)
	(f- . mf-)
	(f* . mf*)
	(f/ . mf/)
	(f? . mf?)
	(f= . mf=)
	(f!= . mf!=)
	(f< . mf<)
	(f> . mf>)
	(f<= . mf<=)
	(f>= . mf>=)

	(u2i . mu2i)
	(i2u . mi2u)
	(f2i . mf2i)
	(i2f . mi2f)
	(c2i . mc2i)
	(i2c . mi2c)
	(c2u . mc2u)
	(u2c . mu2c)

	(vec? . mvec?)
	(mkvec . mmkvec)
	(vec-len . mvec-len)
	(vecmid . mvecmid)
	(vec-el . mvec-el)
	(vec-cat . mvec-cat)

	(b? . mb?)
	(b-len . mb-len)
	(b-cat . mb-cat)
	(bmid . mbmid)
	(i2b . mi2b)
	(f2b . mf2b)
	(c2b . mc2b)
	(u1-2b . mu1-2b)
	(u2-2b . mu2-2b)
	(u4-2b . mu4-2b)
	(u8-2b . mu8-2b)
	(b-geti . mb-geti)
	(b-getf . mb-getf)
	(b-getc . mb-getc)
	(b-getu1 . mb-getu1)
	(b-getu2 . mb-getu2)
	(b-getu4 . mb-getu4)
	(b-getu8 . mb-getu8)

	(sz-i . msz-i)
	(sz-f . msz-f)
	(sz-c . msz-c)
	(sz-u . msz-u)

	(pair? . mpair?)
	(lazy? . mlazy?)
	(label? . mlabel?)
	(context? . mcontext?)
	(atom? . matom?)
	(symbol? . msymbol?)
	(const? . mconst?)
	(macro? . mmacro?)
	(basemacro? . mbasemacro?)
	(usermacro? . musermacro?)
	(stectype? . mstectype?)

	(ctx-get . mctx-get)
	(ctx-push . mctx-push)
	(empty-ctx . mempty-ctx)
	(get-type . mget-type)
	(cons . mcons)
	(car . mcar)
	(cdr . mcdr)
	(eq . meq)
	)

>- nil ()
>- nil? (eq ())
>- not nil?
>- and (\ x \ y (? x y . nil))
>- or (\ x \ y (? x x . y))
>- xor (\ x \ y (? x (nil? y) . y))

>- op-i-f (\ iop \ fop \ x \ y
	? (i? x)
		(? (i? y) (iop x y)
		 ? (f? y) (fop (i2f x) y)
		_)
	? (f? x)
		(? (f? y) (fop x y)
		 ? (i? y) (fop x (i2f y))
		_)
	_)

>- + (op-i-f i+ f+)
>- - (op-i-f i- f-)
>- * (op-i-f i* f*)
>- / (op-i-f i/ f/)


>- list-map (@ map \ f \ list
	? (nil? list) nil
	cons (f (car list)) (map f (cdr list)))

>- list-foldr (@ foldr \ f \ x \ list
	? (nil? list) x
	f (car list) (foldr f (carl list) (cdr list)))

>- list-foldl (@ foldl \ f \ x \ list
	? (nil? list) x
	foldl f (f x (car list)) (cdr list))

>- list-len (@ len \ list
	? (atom? list) 0
	i+ 1 (len (cdr list)))

>- list-append (@ append \ l1 \ l2
	? (nil? l1) l2
	cons (car l1) (append (cdr l1) l2))

>- list-reverse (@ reverse \ list
	? (nil? list) nil
	append (reverse (cdr list)) (cons (car list) nil))

>- list-find-first (@ find \ list \ p
	? (atom? list) list
	? (p list) list
	find (cdr list) p)

>- list-find-first-car (\ list \ p list-find-first list (\ x p (car x)))

>- list-filter-car (@ filter \ list \ p
	>- finded (list-find-first list (\ x p (car x)))
	? (atom? finded) finded
	cons (car finded) (filter (cdr finded) p))

>- list-get-n (@ get \ list \ n
	? (i< n 0) _
	? (atom? list) _
	? (i= n 0) (car list)
	get (cdr list) (i- n 1))

>- list-get-n-cdr (@ get \ list \ n
	? (i< n 0) _
	? (atom? list) _
	? (i= n 0) (cdr list)
	get (cdr list) (i- n 1))

>- list-slice (@ slice \ list \ begin \ end
	? (or (i< begin 0) (or (i< end 0) (i>= begin end))) _
	? (atom? list) _
	? (i= begin end) nil
	cons (car list) (slice (cdr list) (i+ begin 1) end))

>- list-remove-one (@ remove \ list \ p
	? (function? p)
