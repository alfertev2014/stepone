; Файл для прогона простых тестов. Символ ; в начале строки - это строка комментария.
; После выполнившейся стоки следующая строка рассматривается как ожидаемый результат, который не подаётся на вычисление.

()
()

; Базовые макросы

; Проверка quote

(' . a)
a

(' a)
(a)

(' a b c d e)
(a b c d e)

; Проверка if
(? (' . t) (' . a) ' . b)
a

(? () (' . a) ' . b)
b

; Проверка eq

(eq (' . x) . (' . x))
t

(eq () . ())
t

(eq (' x) . (' x))
()

(>- s (^) eq s . s)
t

(eq (^) . (^))
()

; Аксиомы лямбда исчисления

; бетта-редукция
((\ x x) (' . y))
y

; альфа-конверсия
(eq ((\ x x) (' . y)) . ((\ z z) (' . y)))
t

; Несколько аргументов и применение)
((\ x \ y \ z x y z) (\ x \ y x y) (\ x x) (' . a))
a

; let

(>- x (' . y) x)
y

(>- f (\ x x) >- a (' . y) f a)
y

(@ f (' . x))
x

(# (' . x))
x

; передача лени в параметр

((\ x ? () x . t) (# blablabla))
t

; возврат лени
(>- f (\ x (# cons x x)) (\ x ? () x . t) (f (' . blablabla)))
t

; Базовые функции

(car . (' a))
a

(cdr . (' a))
()

(cons (' . a) . (' . b))
(a . b)

(cons (' a) . (' b c d))
((a) b c d)

; Целые числа

1
1

(i+ 2 . 2)
4

(i- 2 . 2)
0

(i* 3 . 4)
12

(i/ 55 . 5)
11

(i+ (i* 3 . 4) . (i* 5 6))
42

(i= 2 . 2)
t

; "Два не может быть больше двух!"
(i> 2 . 2)
()

; Проверка операций с векторами

(mkvec 3 1 2 3)
[1, 2, 3]

(vec-el (mkvec 6 1 2 3 4 5 6) . 4)
5

(vec-cat (mkvec 6 1 2 3 4 5 6) . (mkvec 3 3 2 1))
[1, 2, 3, 4, 5, 6, 3, 2, 1]

(vec-mid (mkvec 6 1 2 3 4 5 6) 2 . 4)
[3, 4]

(vec-len . (mkvec 6 1 2 3 4 5 6))
6

(>- v1 (mkvec 6 1 2 3 4 5 6) >- v2 (mkvec 3 3 2 1) i= (i+ (vec-len . v1) . (vec-len . v2)) (vec-len . (vec-cat v1 . v2)))
t

; get-type

(eq (get-type . 1) . (get-type . (i+ 1 . 2)))
t

(eq (get-type . 1.0) . (get-type . (f/ 1.0 . 2.0)))
t

(eq (get-type . (' . x)) . (get-type . (' . y)))
t

; проверка операций с числами с плавающей точкой

2.0
2

(f+ 2.0 . 2.0)
4

(f- 2.0 . 2.0)
0

(f* 3.0 . 4.0)
12

(f/ 55.0 . 5.0)
11

(f+ (f* 3.0 . 4.0) . (f* 5.0 . 6.0))
42

(f= 2.0 . 2.0)
t

(eq (get-type . 2) . (get-type . 2.0))
()

(eq (get-type . 2.0) . (get-type . (i2f . 2)))
t

(eq (get-type . 2) . (get-type . (f2i . 2.0)))
t

; Проверка байтовых массивов

(b-geti (i2b . 1) . 0)
1

(b-len (i2b . 3))
4

(>- barr (b-cat (i2b . 1) . (i2b . 2)) b-len . barr)
8

(>- barr (b-cat (i2b . 1) . (i2b 2)) cons (b-geti barr . 0) . (b-geti barr . sz-i))
(1 . 2)

; Проверка строк

"[f[f[f[f[f[f["
"[f[f[f[f[f[f["

(b-cat "asdf" . "ghjk")
"asdfghjk"

(b-len . "sdfghjkl")
8

(b-mid "sdfjhkl" 3 . 6)
"jhk"

(b-slice "sdfjhkl" 3 . 6)
"jhk"

; Проверка символов

&" "
&" "

&""
&""

(c= &"g" . &"g")
t

(c= &"g" . &"f")
()

(c!= &"g" . &"g")
()

(c!= &"g" . &"f")
t

; Поиск в строках

(b-findch "sdfghjkl" . &"s")
0

(b-findch "sdfghfjkl" . &"f")
2

(b-findch "sdfghjkl" . &"l")
7

(b-findch "sdfghjkl" . &"b")
-1

(b-find "asdfghjk" . "asdf")
0

(b-find "asdfghjk" . "dfgh")
2

(b-find "asdfghjk" . "hjk")
5

(b-find "asdfghjk" . "asf")
-1

