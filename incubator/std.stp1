
; Наброски того, что в итоге должно быть в стандартной библиотеке


; Логическое И. Вычисляются оба операнда. TODO: чтобы сделать ленивое исполнение, требуется использовать макросы вместо лямбд
; Операнды могут быть любые, просто приводятся к логическому типу
>- and (\ a \ b
    ? a (
        ? b true
        false
    )
    false
)

; Логическое ИЛИ. Всё то же самое.
>- or (\ a \ b
    ? a true
    ? b true
    false
)


; TODO: нужно решить с правилами передачи аргументов: фиксированный кортеж аргументов, со значениями по-умолчанию, с переменным количеством аргументов, с именованными параметрами, и как в этом случае каррировать.
; Аналогичное нужно придумать для макросов.


; TODO: Хочется иметь инфиксные операции как методы. В общем случае метод вызывается как (object method-name arg1 arg2). При этом object выступает как evaluator для выражения (method-name arg1 arg2).
; TODO: Разработать запись (object method-name) без передачи аргументов для получения замыкания метода, эквивалентно (\ arg1 \ arg2 object method-name arg1 arg2). Если это просто property, то придумать синтаксис замыкания для геттера.

; TODO: Потребуется особый тип объявления: метод. Метод кроме своего аргумента должен принимать this.

; TODO: Придумать объектную систему с наследованием, композицией, полиморфизмом, множественной диспетчеризацией, оптимизацией диспетчеризации через jump-таблицы.

; TODO: Встроенные инфиксные операции с числами: делать их как встроенные или искать способ, как их сделать на основе встроенных строготипизированных. (1 + 2) - вызов метода + на объекте 1 с аргументом 2. А что если типы не совпадают? (1 + 2.0) - полиморфный +, реализация зависит от типа аргумента. Где делать диспетчеризацию: встроенную в рантайм или оставить это в библиотеках?

; TODO: В стандартной библиотеке должны быть различные конструкции циклов, операции со списками типа map, flatMap, fold, filter и другие. И не только со списками исходника, но и со списками для данных.

; TODO: Придумать структурные типы - кортежи с безымянными и именованными полями.


; TODO: Можно ли сделать такой evaluator, выполняющий сложные макро-преобразования и исполняющий код налету, а потом подсунуть ему в качестве базового эвалуатора не базовый, а тот, который вместо исполнения трассирует команды и формирует новый исходник, как бы после макро-подстановок? Если только он не будет раскрывать какую-нибудь рекурсию и циклы. Скорее всего, нет.
